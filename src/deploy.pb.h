// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: deploy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_deploy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_deploy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_deploy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_deploy_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_deploy_2eproto;
namespace peony {
namespace delpoy {
namespace models {
class Group;
class GroupDefaultTypeInternal;
extern GroupDefaultTypeInternal _Group_default_instance_;
class Inventory;
class InventoryDefaultTypeInternal;
extern InventoryDefaultTypeInternal _Inventory_default_instance_;
class Log;
class LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class Recipe;
class RecipeDefaultTypeInternal;
extern RecipeDefaultTypeInternal _Recipe_default_instance_;
class Ssh;
class SshDefaultTypeInternal;
extern SshDefaultTypeInternal _Ssh_default_instance_;
class Task;
class TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class Task_Download;
class Task_DownloadDefaultTypeInternal;
extern Task_DownloadDefaultTypeInternal _Task_Download_default_instance_;
class Task_Shell;
class Task_ShellDefaultTypeInternal;
extern Task_ShellDefaultTypeInternal _Task_Shell_default_instance_;
class Task_Upload;
class Task_UploadDefaultTypeInternal;
extern Task_UploadDefaultTypeInternal _Task_Upload_default_instance_;
}  // namespace models
}  // namespace delpoy
}  // namespace peony
PROTOBUF_NAMESPACE_OPEN
template<> ::peony::delpoy::models::Group* Arena::CreateMaybeMessage<::peony::delpoy::models::Group>(Arena*);
template<> ::peony::delpoy::models::Inventory* Arena::CreateMaybeMessage<::peony::delpoy::models::Inventory>(Arena*);
template<> ::peony::delpoy::models::Log* Arena::CreateMaybeMessage<::peony::delpoy::models::Log>(Arena*);
template<> ::peony::delpoy::models::Recipe* Arena::CreateMaybeMessage<::peony::delpoy::models::Recipe>(Arena*);
template<> ::peony::delpoy::models::Ssh* Arena::CreateMaybeMessage<::peony::delpoy::models::Ssh>(Arena*);
template<> ::peony::delpoy::models::Task* Arena::CreateMaybeMessage<::peony::delpoy::models::Task>(Arena*);
template<> ::peony::delpoy::models::Task_Download* Arena::CreateMaybeMessage<::peony::delpoy::models::Task_Download>(Arena*);
template<> ::peony::delpoy::models::Task_Shell* Arena::CreateMaybeMessage<::peony::delpoy::models::Task_Shell>(Arena*);
template<> ::peony::delpoy::models::Task_Upload* Arena::CreateMaybeMessage<::peony::delpoy::models::Task_Upload>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace peony {
namespace delpoy {
namespace models {

// ===================================================================

class Task_Shell PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.delpoy.models.Task.Shell) */ {
 public:
  inline Task_Shell() : Task_Shell(nullptr) {}
  virtual ~Task_Shell();

  Task_Shell(const Task_Shell& from);
  Task_Shell(Task_Shell&& from) noexcept
    : Task_Shell() {
    *this = ::std::move(from);
  }

  inline Task_Shell& operator=(const Task_Shell& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task_Shell& operator=(Task_Shell&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Task_Shell& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Task_Shell* internal_default_instance() {
    return reinterpret_cast<const Task_Shell*>(
               &_Task_Shell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Task_Shell& a, Task_Shell& b) {
    a.Swap(&b);
  }
  inline void Swap(Task_Shell* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task_Shell* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Task_Shell* New() const final {
    return CreateMaybeMessage<Task_Shell>(nullptr);
  }

  Task_Shell* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Task_Shell>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Task_Shell& from);
  void MergeFrom(const Task_Shell& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task_Shell* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.delpoy.models.Task.Shell";
  }
  protected:
  explicit Task_Shell(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptFieldNumber = 1,
  };
  // string script = 1;
  void clear_script();
  const std::string& script() const;
  void set_script(const std::string& value);
  void set_script(std::string&& value);
  void set_script(const char* value);
  void set_script(const char* value, size_t size);
  std::string* mutable_script();
  std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // @@protoc_insertion_point(class_scope:peony.delpoy.models.Task.Shell)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Task_Upload PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.delpoy.models.Task.Upload) */ {
 public:
  inline Task_Upload() : Task_Upload(nullptr) {}
  virtual ~Task_Upload();

  Task_Upload(const Task_Upload& from);
  Task_Upload(Task_Upload&& from) noexcept
    : Task_Upload() {
    *this = ::std::move(from);
  }

  inline Task_Upload& operator=(const Task_Upload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task_Upload& operator=(Task_Upload&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Task_Upload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Task_Upload* internal_default_instance() {
    return reinterpret_cast<const Task_Upload*>(
               &_Task_Upload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Task_Upload& a, Task_Upload& b) {
    a.Swap(&b);
  }
  inline void Swap(Task_Upload* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task_Upload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Task_Upload* New() const final {
    return CreateMaybeMessage<Task_Upload>(nullptr);
  }

  Task_Upload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Task_Upload>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Task_Upload& from);
  void MergeFrom(const Task_Upload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task_Upload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.delpoy.models.Task.Upload";
  }
  protected:
  explicit Task_Upload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDestFieldNumber = 2,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  void set_src(const std::string& value);
  void set_src(std::string&& value);
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  std::string* mutable_src();
  std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // string dest = 2;
  void clear_dest();
  const std::string& dest() const;
  void set_dest(const std::string& value);
  void set_dest(std::string&& value);
  void set_dest(const char* value);
  void set_dest(const char* value, size_t size);
  std::string* mutable_dest();
  std::string* release_dest();
  void set_allocated_dest(std::string* dest);
  private:
  const std::string& _internal_dest() const;
  void _internal_set_dest(const std::string& value);
  std::string* _internal_mutable_dest();
  public:

  // @@protoc_insertion_point(class_scope:peony.delpoy.models.Task.Upload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Task_Download PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.delpoy.models.Task.Download) */ {
 public:
  inline Task_Download() : Task_Download(nullptr) {}
  virtual ~Task_Download();

  Task_Download(const Task_Download& from);
  Task_Download(Task_Download&& from) noexcept
    : Task_Download() {
    *this = ::std::move(from);
  }

  inline Task_Download& operator=(const Task_Download& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task_Download& operator=(Task_Download&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Task_Download& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Task_Download* internal_default_instance() {
    return reinterpret_cast<const Task_Download*>(
               &_Task_Download_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Task_Download& a, Task_Download& b) {
    a.Swap(&b);
  }
  inline void Swap(Task_Download* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task_Download* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Task_Download* New() const final {
    return CreateMaybeMessage<Task_Download>(nullptr);
  }

  Task_Download* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Task_Download>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Task_Download& from);
  void MergeFrom(const Task_Download& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task_Download* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.delpoy.models.Task.Download";
  }
  protected:
  explicit Task_Download(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDestFieldNumber = 2,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  void set_src(const std::string& value);
  void set_src(std::string&& value);
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  std::string* mutable_src();
  std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // string dest = 2;
  void clear_dest();
  const std::string& dest() const;
  void set_dest(const std::string& value);
  void set_dest(std::string&& value);
  void set_dest(const char* value);
  void set_dest(const char* value, size_t size);
  std::string* mutable_dest();
  std::string* release_dest();
  void set_allocated_dest(std::string* dest);
  private:
  const std::string& _internal_dest() const;
  void _internal_set_dest(const std::string& value);
  std::string* _internal_mutable_dest();
  public:

  // @@protoc_insertion_point(class_scope:peony.delpoy.models.Task.Download)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Task PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.delpoy.models.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  virtual ~Task();

  Task(const Task& from);
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Task& default_instance();

  enum PayloadCase {
    kShell = 2,
    kUpload = 3,
    kDownload = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Task* New() const final {
    return CreateMaybeMessage<Task>(nullptr);
  }

  Task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.delpoy.models.Task";
  }
  protected:
  explicit Task(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Task_Shell Shell;
  typedef Task_Upload Upload;
  typedef Task_Download Download;

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 5,
    kHostsFieldNumber = 6,
    kNameFieldNumber = 1,
    kShellFieldNumber = 2,
    kUploadFieldNumber = 3,
    kDownloadFieldNumber = 4,
  };
  // repeated string groups = 5;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  const std::string& groups(int index) const;
  std::string* mutable_groups(int index);
  void set_groups(int index, const std::string& value);
  void set_groups(int index, std::string&& value);
  void set_groups(int index, const char* value);
  void set_groups(int index, const char* value, size_t size);
  std::string* add_groups();
  void add_groups(const std::string& value);
  void add_groups(std::string&& value);
  void add_groups(const char* value);
  void add_groups(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& groups() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_groups();
  private:
  const std::string& _internal_groups(int index) const;
  std::string* _internal_add_groups();
  public:

  // repeated string hosts = 6;
  int hosts_size() const;
  private:
  int _internal_hosts_size() const;
  public:
  void clear_hosts();
  const std::string& hosts(int index) const;
  std::string* mutable_hosts(int index);
  void set_hosts(int index, const std::string& value);
  void set_hosts(int index, std::string&& value);
  void set_hosts(int index, const char* value);
  void set_hosts(int index, const char* value, size_t size);
  std::string* add_hosts();
  void add_hosts(const std::string& value);
  void add_hosts(std::string&& value);
  void add_hosts(const char* value);
  void add_hosts(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hosts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hosts();
  private:
  const std::string& _internal_hosts(int index) const;
  std::string* _internal_add_hosts();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .peony.delpoy.models.Task.Shell shell = 2;
  bool has_shell() const;
  private:
  bool _internal_has_shell() const;
  public:
  void clear_shell();
  const ::peony::delpoy::models::Task_Shell& shell() const;
  ::peony::delpoy::models::Task_Shell* release_shell();
  ::peony::delpoy::models::Task_Shell* mutable_shell();
  void set_allocated_shell(::peony::delpoy::models::Task_Shell* shell);
  private:
  const ::peony::delpoy::models::Task_Shell& _internal_shell() const;
  ::peony::delpoy::models::Task_Shell* _internal_mutable_shell();
  public:
  void unsafe_arena_set_allocated_shell(
      ::peony::delpoy::models::Task_Shell* shell);
  ::peony::delpoy::models::Task_Shell* unsafe_arena_release_shell();

  // .peony.delpoy.models.Task.Upload upload = 3;
  bool has_upload() const;
  private:
  bool _internal_has_upload() const;
  public:
  void clear_upload();
  const ::peony::delpoy::models::Task_Upload& upload() const;
  ::peony::delpoy::models::Task_Upload* release_upload();
  ::peony::delpoy::models::Task_Upload* mutable_upload();
  void set_allocated_upload(::peony::delpoy::models::Task_Upload* upload);
  private:
  const ::peony::delpoy::models::Task_Upload& _internal_upload() const;
  ::peony::delpoy::models::Task_Upload* _internal_mutable_upload();
  public:
  void unsafe_arena_set_allocated_upload(
      ::peony::delpoy::models::Task_Upload* upload);
  ::peony::delpoy::models::Task_Upload* unsafe_arena_release_upload();

  // .peony.delpoy.models.Task.Download download = 4;
  bool has_download() const;
  private:
  bool _internal_has_download() const;
  public:
  void clear_download();
  const ::peony::delpoy::models::Task_Download& download() const;
  ::peony::delpoy::models::Task_Download* release_download();
  ::peony::delpoy::models::Task_Download* mutable_download();
  void set_allocated_download(::peony::delpoy::models::Task_Download* download);
  private:
  const ::peony::delpoy::models::Task_Download& _internal_download() const;
  ::peony::delpoy::models::Task_Download* _internal_mutable_download();
  public:
  void unsafe_arena_set_allocated_download(
      ::peony::delpoy::models::Task_Download* download);
  ::peony::delpoy::models::Task_Download* unsafe_arena_release_download();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:peony.delpoy.models.Task)
 private:
  class _Internal;
  void set_has_shell();
  void set_has_upload();
  void set_has_download();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> groups_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hosts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  union PayloadUnion {
    PayloadUnion() {}
    ::peony::delpoy::models::Task_Shell* shell_;
    ::peony::delpoy::models::Task_Upload* upload_;
    ::peony::delpoy::models::Task_Download* download_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Recipe PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.delpoy.models.Recipe) */ {
 public:
  inline Recipe() : Recipe(nullptr) {}
  virtual ~Recipe();

  Recipe(const Recipe& from);
  Recipe(Recipe&& from) noexcept
    : Recipe() {
    *this = ::std::move(from);
  }

  inline Recipe& operator=(const Recipe& from) {
    CopyFrom(from);
    return *this;
  }
  inline Recipe& operator=(Recipe&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Recipe& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Recipe* internal_default_instance() {
    return reinterpret_cast<const Recipe*>(
               &_Recipe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Recipe& a, Recipe& b) {
    a.Swap(&b);
  }
  inline void Swap(Recipe* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Recipe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Recipe* New() const final {
    return CreateMaybeMessage<Recipe>(nullptr);
  }

  Recipe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Recipe>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Recipe& from);
  void MergeFrom(const Recipe& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Recipe* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.delpoy.models.Recipe";
  }
  protected:
  explicit Recipe(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .peony.delpoy.models.Task tasks = 2;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;
  public:
  void clear_tasks();
  ::peony::delpoy::models::Task* mutable_tasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::delpoy::models::Task >*
      mutable_tasks();
  private:
  const ::peony::delpoy::models::Task& _internal_tasks(int index) const;
  ::peony::delpoy::models::Task* _internal_add_tasks();
  public:
  const ::peony::delpoy::models::Task& tasks(int index) const;
  ::peony::delpoy::models::Task* add_tasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::delpoy::models::Task >&
      tasks() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:peony.delpoy.models.Recipe)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::delpoy::models::Task > tasks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Ssh PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.delpoy.models.Ssh) */ {
 public:
  inline Ssh() : Ssh(nullptr) {}
  virtual ~Ssh();

  Ssh(const Ssh& from);
  Ssh(Ssh&& from) noexcept
    : Ssh() {
    *this = ::std::move(from);
  }

  inline Ssh& operator=(const Ssh& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ssh& operator=(Ssh&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Ssh& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ssh* internal_default_instance() {
    return reinterpret_cast<const Ssh*>(
               &_Ssh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Ssh& a, Ssh& b) {
    a.Swap(&b);
  }
  inline void Swap(Ssh* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ssh* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ssh* New() const final {
    return CreateMaybeMessage<Ssh>(nullptr);
  }

  Ssh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ssh>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Ssh& from);
  void MergeFrom(const Ssh& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ssh* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.delpoy.models.Ssh";
  }
  protected:
  explicit Ssh(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
    kUserFieldNumber = 3,
    kKeyFieldNumber = 4,
    kPortFieldNumber = 2,
  };
  // string host = 1;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string user = 3;
  void clear_user();
  const std::string& user() const;
  void set_user(const std::string& value);
  void set_user(std::string&& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  std::string* mutable_user();
  std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string key = 4;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // int32 port = 2;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:peony.delpoy.models.Ssh)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Group PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.delpoy.models.Group) */ {
 public:
  inline Group() : Group(nullptr) {}
  virtual ~Group();

  Group(const Group& from);
  Group(Group&& from) noexcept
    : Group() {
    *this = ::std::move(from);
  }

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }
  inline Group& operator=(Group&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Group& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Group* internal_default_instance() {
    return reinterpret_cast<const Group*>(
               &_Group_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Group& a, Group& b) {
    a.Swap(&b);
  }
  inline void Swap(Group* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Group* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Group* New() const final {
    return CreateMaybeMessage<Group>(nullptr);
  }

  Group* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Group>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Group* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.delpoy.models.Group";
  }
  protected:
  explicit Group(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostsFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated string hosts = 2;
  int hosts_size() const;
  private:
  int _internal_hosts_size() const;
  public:
  void clear_hosts();
  const std::string& hosts(int index) const;
  std::string* mutable_hosts(int index);
  void set_hosts(int index, const std::string& value);
  void set_hosts(int index, std::string&& value);
  void set_hosts(int index, const char* value);
  void set_hosts(int index, const char* value, size_t size);
  std::string* add_hosts();
  void add_hosts(const std::string& value);
  void add_hosts(std::string&& value);
  void add_hosts(const char* value);
  void add_hosts(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hosts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hosts();
  private:
  const std::string& _internal_hosts(int index) const;
  std::string* _internal_add_hosts();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:peony.delpoy.models.Group)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hosts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Inventory PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.delpoy.models.Inventory) */ {
 public:
  inline Inventory() : Inventory(nullptr) {}
  virtual ~Inventory();

  Inventory(const Inventory& from);
  Inventory(Inventory&& from) noexcept
    : Inventory() {
    *this = ::std::move(from);
  }

  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inventory& operator=(Inventory&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Inventory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Inventory* internal_default_instance() {
    return reinterpret_cast<const Inventory*>(
               &_Inventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Inventory& a, Inventory& b) {
    a.Swap(&b);
  }
  inline void Swap(Inventory* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Inventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Inventory* New() const final {
    return CreateMaybeMessage<Inventory>(nullptr);
  }

  Inventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Inventory>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Inventory& from);
  void MergeFrom(const Inventory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Inventory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.delpoy.models.Inventory";
  }
  protected:
  explicit Inventory(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 2,
    kHostsFieldNumber = 3,
    kNameFieldNumber = 1,
  };
  // repeated string groups = 2;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  const std::string& groups(int index) const;
  std::string* mutable_groups(int index);
  void set_groups(int index, const std::string& value);
  void set_groups(int index, std::string&& value);
  void set_groups(int index, const char* value);
  void set_groups(int index, const char* value, size_t size);
  std::string* add_groups();
  void add_groups(const std::string& value);
  void add_groups(std::string&& value);
  void add_groups(const char* value);
  void add_groups(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& groups() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_groups();
  private:
  const std::string& _internal_groups(int index) const;
  std::string* _internal_add_groups();
  public:

  // repeated string hosts = 3;
  int hosts_size() const;
  private:
  int _internal_hosts_size() const;
  public:
  void clear_hosts();
  const std::string& hosts(int index) const;
  std::string* mutable_hosts(int index);
  void set_hosts(int index, const std::string& value);
  void set_hosts(int index, std::string&& value);
  void set_hosts(int index, const char* value);
  void set_hosts(int index, const char* value, size_t size);
  std::string* add_hosts();
  void add_hosts(const std::string& value);
  void add_hosts(std::string&& value);
  void add_hosts(const char* value);
  void add_hosts(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hosts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hosts();
  private:
  const std::string& _internal_hosts(int index) const;
  std::string* _internal_add_hosts();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:peony.delpoy.models.Inventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> groups_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hosts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Log PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.delpoy.models.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  virtual ~Log();

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Log& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Log* New() const final {
    return CreateMaybeMessage<Log>(nullptr);
  }

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.delpoy.models.Log";
  }
  protected:
  explicit Log(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInventoryFieldNumber = 1,
    kGroupFieldNumber = 2,
    kUserFieldNumber = 3,
    kHostFieldNumber = 4,
    kReacipeFieldNumber = 5,
    kTaskFieldNumber = 6,
  };
  // string inventory = 1;
  void clear_inventory();
  const std::string& inventory() const;
  void set_inventory(const std::string& value);
  void set_inventory(std::string&& value);
  void set_inventory(const char* value);
  void set_inventory(const char* value, size_t size);
  std::string* mutable_inventory();
  std::string* release_inventory();
  void set_allocated_inventory(std::string* inventory);
  private:
  const std::string& _internal_inventory() const;
  void _internal_set_inventory(const std::string& value);
  std::string* _internal_mutable_inventory();
  public:

  // string group = 2;
  void clear_group();
  const std::string& group() const;
  void set_group(const std::string& value);
  void set_group(std::string&& value);
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  std::string* mutable_group();
  std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // string user = 3;
  void clear_user();
  const std::string& user() const;
  void set_user(const std::string& value);
  void set_user(std::string&& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  std::string* mutable_user();
  std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string host = 4;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string reacipe = 5;
  void clear_reacipe();
  const std::string& reacipe() const;
  void set_reacipe(const std::string& value);
  void set_reacipe(std::string&& value);
  void set_reacipe(const char* value);
  void set_reacipe(const char* value, size_t size);
  std::string* mutable_reacipe();
  std::string* release_reacipe();
  void set_allocated_reacipe(std::string* reacipe);
  private:
  const std::string& _internal_reacipe() const;
  void _internal_set_reacipe(const std::string& value);
  std::string* _internal_mutable_reacipe();
  public:

  // string task = 6;
  void clear_task();
  const std::string& task() const;
  void set_task(const std::string& value);
  void set_task(std::string&& value);
  void set_task(const char* value);
  void set_task(const char* value, size_t size);
  std::string* mutable_task();
  std::string* release_task();
  void set_allocated_task(std::string* task);
  private:
  const std::string& _internal_task() const;
  void _internal_set_task(const std::string& value);
  std::string* _internal_mutable_task();
  public:

  // @@protoc_insertion_point(class_scope:peony.delpoy.models.Log)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inventory_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reacipe_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Task_Shell

// string script = 1;
inline void Task_Shell::clear_script() {
  script_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Task_Shell::script() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Task.Shell.script)
  return _internal_script();
}
inline void Task_Shell::set_script(const std::string& value) {
  _internal_set_script(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Task.Shell.script)
}
inline std::string* Task_Shell::mutable_script() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Task.Shell.script)
  return _internal_mutable_script();
}
inline const std::string& Task_Shell::_internal_script() const {
  return script_.Get();
}
inline void Task_Shell::_internal_set_script(const std::string& value) {
  
  script_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Task_Shell::set_script(std::string&& value) {
  
  script_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Task.Shell.script)
}
inline void Task_Shell::set_script(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  script_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Task.Shell.script)
}
inline void Task_Shell::set_script(const char* value,
    size_t size) {
  
  script_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Task.Shell.script)
}
inline std::string* Task_Shell::_internal_mutable_script() {
  
  return script_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Task_Shell::release_script() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Task.Shell.script)
  return script_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Task_Shell::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  script_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), script,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Task.Shell.script)
}

// -------------------------------------------------------------------

// Task_Upload

// string src = 1;
inline void Task_Upload::clear_src() {
  src_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Task_Upload::src() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Task.Upload.src)
  return _internal_src();
}
inline void Task_Upload::set_src(const std::string& value) {
  _internal_set_src(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Task.Upload.src)
}
inline std::string* Task_Upload::mutable_src() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Task.Upload.src)
  return _internal_mutable_src();
}
inline const std::string& Task_Upload::_internal_src() const {
  return src_.Get();
}
inline void Task_Upload::_internal_set_src(const std::string& value) {
  
  src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Task_Upload::set_src(std::string&& value) {
  
  src_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Task.Upload.src)
}
inline void Task_Upload::set_src(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Task.Upload.src)
}
inline void Task_Upload::set_src(const char* value,
    size_t size) {
  
  src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Task.Upload.src)
}
inline std::string* Task_Upload::_internal_mutable_src() {
  
  return src_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Task_Upload::release_src() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Task.Upload.src)
  return src_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Task_Upload::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  src_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Task.Upload.src)
}

// string dest = 2;
inline void Task_Upload::clear_dest() {
  dest_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Task_Upload::dest() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Task.Upload.dest)
  return _internal_dest();
}
inline void Task_Upload::set_dest(const std::string& value) {
  _internal_set_dest(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Task.Upload.dest)
}
inline std::string* Task_Upload::mutable_dest() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Task.Upload.dest)
  return _internal_mutable_dest();
}
inline const std::string& Task_Upload::_internal_dest() const {
  return dest_.Get();
}
inline void Task_Upload::_internal_set_dest(const std::string& value) {
  
  dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Task_Upload::set_dest(std::string&& value) {
  
  dest_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Task.Upload.dest)
}
inline void Task_Upload::set_dest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Task.Upload.dest)
}
inline void Task_Upload::set_dest(const char* value,
    size_t size) {
  
  dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Task.Upload.dest)
}
inline std::string* Task_Upload::_internal_mutable_dest() {
  
  return dest_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Task_Upload::release_dest() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Task.Upload.dest)
  return dest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Task_Upload::set_allocated_dest(std::string* dest) {
  if (dest != nullptr) {
    
  } else {
    
  }
  dest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dest,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Task.Upload.dest)
}

// -------------------------------------------------------------------

// Task_Download

// string src = 1;
inline void Task_Download::clear_src() {
  src_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Task_Download::src() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Task.Download.src)
  return _internal_src();
}
inline void Task_Download::set_src(const std::string& value) {
  _internal_set_src(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Task.Download.src)
}
inline std::string* Task_Download::mutable_src() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Task.Download.src)
  return _internal_mutable_src();
}
inline const std::string& Task_Download::_internal_src() const {
  return src_.Get();
}
inline void Task_Download::_internal_set_src(const std::string& value) {
  
  src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Task_Download::set_src(std::string&& value) {
  
  src_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Task.Download.src)
}
inline void Task_Download::set_src(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Task.Download.src)
}
inline void Task_Download::set_src(const char* value,
    size_t size) {
  
  src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Task.Download.src)
}
inline std::string* Task_Download::_internal_mutable_src() {
  
  return src_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Task_Download::release_src() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Task.Download.src)
  return src_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Task_Download::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  src_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Task.Download.src)
}

// string dest = 2;
inline void Task_Download::clear_dest() {
  dest_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Task_Download::dest() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Task.Download.dest)
  return _internal_dest();
}
inline void Task_Download::set_dest(const std::string& value) {
  _internal_set_dest(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Task.Download.dest)
}
inline std::string* Task_Download::mutable_dest() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Task.Download.dest)
  return _internal_mutable_dest();
}
inline const std::string& Task_Download::_internal_dest() const {
  return dest_.Get();
}
inline void Task_Download::_internal_set_dest(const std::string& value) {
  
  dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Task_Download::set_dest(std::string&& value) {
  
  dest_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Task.Download.dest)
}
inline void Task_Download::set_dest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Task.Download.dest)
}
inline void Task_Download::set_dest(const char* value,
    size_t size) {
  
  dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Task.Download.dest)
}
inline std::string* Task_Download::_internal_mutable_dest() {
  
  return dest_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Task_Download::release_dest() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Task.Download.dest)
  return dest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Task_Download::set_allocated_dest(std::string* dest) {
  if (dest != nullptr) {
    
  } else {
    
  }
  dest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dest,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Task.Download.dest)
}

// -------------------------------------------------------------------

// Task

// string name = 1;
inline void Task::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Task::name() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Task.name)
  return _internal_name();
}
inline void Task::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Task.name)
}
inline std::string* Task::mutable_name() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Task.name)
  return _internal_mutable_name();
}
inline const std::string& Task::_internal_name() const {
  return name_.Get();
}
inline void Task::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Task::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Task.name)
}
inline void Task::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Task.name)
}
inline void Task::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Task.name)
}
inline std::string* Task::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Task::release_name() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Task.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Task::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Task.name)
}

// .peony.delpoy.models.Task.Shell shell = 2;
inline bool Task::_internal_has_shell() const {
  return payload_case() == kShell;
}
inline bool Task::has_shell() const {
  return _internal_has_shell();
}
inline void Task::set_has_shell() {
  _oneof_case_[0] = kShell;
}
inline void Task::clear_shell() {
  if (_internal_has_shell()) {
    if (GetArena() == nullptr) {
      delete payload_.shell_;
    }
    clear_has_payload();
  }
}
inline ::peony::delpoy::models::Task_Shell* Task::release_shell() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Task.shell)
  if (_internal_has_shell()) {
    clear_has_payload();
      ::peony::delpoy::models::Task_Shell* temp = payload_.shell_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.shell_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::peony::delpoy::models::Task_Shell& Task::_internal_shell() const {
  return _internal_has_shell()
      ? *payload_.shell_
      : *reinterpret_cast< ::peony::delpoy::models::Task_Shell*>(&::peony::delpoy::models::_Task_Shell_default_instance_);
}
inline const ::peony::delpoy::models::Task_Shell& Task::shell() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Task.shell)
  return _internal_shell();
}
inline ::peony::delpoy::models::Task_Shell* Task::unsafe_arena_release_shell() {
  // @@protoc_insertion_point(field_unsafe_arena_release:peony.delpoy.models.Task.shell)
  if (_internal_has_shell()) {
    clear_has_payload();
    ::peony::delpoy::models::Task_Shell* temp = payload_.shell_;
    payload_.shell_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Task::unsafe_arena_set_allocated_shell(::peony::delpoy::models::Task_Shell* shell) {
  clear_payload();
  if (shell) {
    set_has_shell();
    payload_.shell_ = shell;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:peony.delpoy.models.Task.shell)
}
inline ::peony::delpoy::models::Task_Shell* Task::_internal_mutable_shell() {
  if (!_internal_has_shell()) {
    clear_payload();
    set_has_shell();
    payload_.shell_ = CreateMaybeMessage< ::peony::delpoy::models::Task_Shell >(GetArena());
  }
  return payload_.shell_;
}
inline ::peony::delpoy::models::Task_Shell* Task::mutable_shell() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Task.shell)
  return _internal_mutable_shell();
}

// .peony.delpoy.models.Task.Upload upload = 3;
inline bool Task::_internal_has_upload() const {
  return payload_case() == kUpload;
}
inline bool Task::has_upload() const {
  return _internal_has_upload();
}
inline void Task::set_has_upload() {
  _oneof_case_[0] = kUpload;
}
inline void Task::clear_upload() {
  if (_internal_has_upload()) {
    if (GetArena() == nullptr) {
      delete payload_.upload_;
    }
    clear_has_payload();
  }
}
inline ::peony::delpoy::models::Task_Upload* Task::release_upload() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Task.upload)
  if (_internal_has_upload()) {
    clear_has_payload();
      ::peony::delpoy::models::Task_Upload* temp = payload_.upload_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.upload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::peony::delpoy::models::Task_Upload& Task::_internal_upload() const {
  return _internal_has_upload()
      ? *payload_.upload_
      : *reinterpret_cast< ::peony::delpoy::models::Task_Upload*>(&::peony::delpoy::models::_Task_Upload_default_instance_);
}
inline const ::peony::delpoy::models::Task_Upload& Task::upload() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Task.upload)
  return _internal_upload();
}
inline ::peony::delpoy::models::Task_Upload* Task::unsafe_arena_release_upload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:peony.delpoy.models.Task.upload)
  if (_internal_has_upload()) {
    clear_has_payload();
    ::peony::delpoy::models::Task_Upload* temp = payload_.upload_;
    payload_.upload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Task::unsafe_arena_set_allocated_upload(::peony::delpoy::models::Task_Upload* upload) {
  clear_payload();
  if (upload) {
    set_has_upload();
    payload_.upload_ = upload;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:peony.delpoy.models.Task.upload)
}
inline ::peony::delpoy::models::Task_Upload* Task::_internal_mutable_upload() {
  if (!_internal_has_upload()) {
    clear_payload();
    set_has_upload();
    payload_.upload_ = CreateMaybeMessage< ::peony::delpoy::models::Task_Upload >(GetArena());
  }
  return payload_.upload_;
}
inline ::peony::delpoy::models::Task_Upload* Task::mutable_upload() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Task.upload)
  return _internal_mutable_upload();
}

// .peony.delpoy.models.Task.Download download = 4;
inline bool Task::_internal_has_download() const {
  return payload_case() == kDownload;
}
inline bool Task::has_download() const {
  return _internal_has_download();
}
inline void Task::set_has_download() {
  _oneof_case_[0] = kDownload;
}
inline void Task::clear_download() {
  if (_internal_has_download()) {
    if (GetArena() == nullptr) {
      delete payload_.download_;
    }
    clear_has_payload();
  }
}
inline ::peony::delpoy::models::Task_Download* Task::release_download() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Task.download)
  if (_internal_has_download()) {
    clear_has_payload();
      ::peony::delpoy::models::Task_Download* temp = payload_.download_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.download_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::peony::delpoy::models::Task_Download& Task::_internal_download() const {
  return _internal_has_download()
      ? *payload_.download_
      : *reinterpret_cast< ::peony::delpoy::models::Task_Download*>(&::peony::delpoy::models::_Task_Download_default_instance_);
}
inline const ::peony::delpoy::models::Task_Download& Task::download() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Task.download)
  return _internal_download();
}
inline ::peony::delpoy::models::Task_Download* Task::unsafe_arena_release_download() {
  // @@protoc_insertion_point(field_unsafe_arena_release:peony.delpoy.models.Task.download)
  if (_internal_has_download()) {
    clear_has_payload();
    ::peony::delpoy::models::Task_Download* temp = payload_.download_;
    payload_.download_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Task::unsafe_arena_set_allocated_download(::peony::delpoy::models::Task_Download* download) {
  clear_payload();
  if (download) {
    set_has_download();
    payload_.download_ = download;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:peony.delpoy.models.Task.download)
}
inline ::peony::delpoy::models::Task_Download* Task::_internal_mutable_download() {
  if (!_internal_has_download()) {
    clear_payload();
    set_has_download();
    payload_.download_ = CreateMaybeMessage< ::peony::delpoy::models::Task_Download >(GetArena());
  }
  return payload_.download_;
}
inline ::peony::delpoy::models::Task_Download* Task::mutable_download() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Task.download)
  return _internal_mutable_download();
}

// repeated string groups = 5;
inline int Task::_internal_groups_size() const {
  return groups_.size();
}
inline int Task::groups_size() const {
  return _internal_groups_size();
}
inline void Task::clear_groups() {
  groups_.Clear();
}
inline std::string* Task::add_groups() {
  // @@protoc_insertion_point(field_add_mutable:peony.delpoy.models.Task.groups)
  return _internal_add_groups();
}
inline const std::string& Task::_internal_groups(int index) const {
  return groups_.Get(index);
}
inline const std::string& Task::groups(int index) const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Task.groups)
  return _internal_groups(index);
}
inline std::string* Task::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Task.groups)
  return groups_.Mutable(index);
}
inline void Task::set_groups(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Task.groups)
  groups_.Mutable(index)->assign(value);
}
inline void Task::set_groups(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Task.groups)
  groups_.Mutable(index)->assign(std::move(value));
}
inline void Task::set_groups(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Task.groups)
}
inline void Task::set_groups(int index, const char* value, size_t size) {
  groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Task.groups)
}
inline std::string* Task::_internal_add_groups() {
  return groups_.Add();
}
inline void Task::add_groups(const std::string& value) {
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:peony.delpoy.models.Task.groups)
}
inline void Task::add_groups(std::string&& value) {
  groups_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:peony.delpoy.models.Task.groups)
}
inline void Task::add_groups(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:peony.delpoy.models.Task.groups)
}
inline void Task::add_groups(const char* value, size_t size) {
  groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:peony.delpoy.models.Task.groups)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Task::groups() const {
  // @@protoc_insertion_point(field_list:peony.delpoy.models.Task.groups)
  return groups_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Task::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:peony.delpoy.models.Task.groups)
  return &groups_;
}

// repeated string hosts = 6;
inline int Task::_internal_hosts_size() const {
  return hosts_.size();
}
inline int Task::hosts_size() const {
  return _internal_hosts_size();
}
inline void Task::clear_hosts() {
  hosts_.Clear();
}
inline std::string* Task::add_hosts() {
  // @@protoc_insertion_point(field_add_mutable:peony.delpoy.models.Task.hosts)
  return _internal_add_hosts();
}
inline const std::string& Task::_internal_hosts(int index) const {
  return hosts_.Get(index);
}
inline const std::string& Task::hosts(int index) const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Task.hosts)
  return _internal_hosts(index);
}
inline std::string* Task::mutable_hosts(int index) {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Task.hosts)
  return hosts_.Mutable(index);
}
inline void Task::set_hosts(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Task.hosts)
  hosts_.Mutable(index)->assign(value);
}
inline void Task::set_hosts(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Task.hosts)
  hosts_.Mutable(index)->assign(std::move(value));
}
inline void Task::set_hosts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Task.hosts)
}
inline void Task::set_hosts(int index, const char* value, size_t size) {
  hosts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Task.hosts)
}
inline std::string* Task::_internal_add_hosts() {
  return hosts_.Add();
}
inline void Task::add_hosts(const std::string& value) {
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:peony.delpoy.models.Task.hosts)
}
inline void Task::add_hosts(std::string&& value) {
  hosts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:peony.delpoy.models.Task.hosts)
}
inline void Task::add_hosts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:peony.delpoy.models.Task.hosts)
}
inline void Task::add_hosts(const char* value, size_t size) {
  hosts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:peony.delpoy.models.Task.hosts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Task::hosts() const {
  // @@protoc_insertion_point(field_list:peony.delpoy.models.Task.hosts)
  return hosts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Task::mutable_hosts() {
  // @@protoc_insertion_point(field_mutable_list:peony.delpoy.models.Task.hosts)
  return &hosts_;
}

inline bool Task::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Task::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Task::PayloadCase Task::payload_case() const {
  return Task::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Recipe

// string name = 1;
inline void Recipe::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Recipe::name() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Recipe.name)
  return _internal_name();
}
inline void Recipe::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Recipe.name)
}
inline std::string* Recipe::mutable_name() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Recipe.name)
  return _internal_mutable_name();
}
inline const std::string& Recipe::_internal_name() const {
  return name_.Get();
}
inline void Recipe::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Recipe::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Recipe.name)
}
inline void Recipe::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Recipe.name)
}
inline void Recipe::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Recipe.name)
}
inline std::string* Recipe::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Recipe::release_name() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Recipe.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Recipe::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Recipe.name)
}

// repeated .peony.delpoy.models.Task tasks = 2;
inline int Recipe::_internal_tasks_size() const {
  return tasks_.size();
}
inline int Recipe::tasks_size() const {
  return _internal_tasks_size();
}
inline void Recipe::clear_tasks() {
  tasks_.Clear();
}
inline ::peony::delpoy::models::Task* Recipe::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Recipe.tasks)
  return tasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::delpoy::models::Task >*
Recipe::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:peony.delpoy.models.Recipe.tasks)
  return &tasks_;
}
inline const ::peony::delpoy::models::Task& Recipe::_internal_tasks(int index) const {
  return tasks_.Get(index);
}
inline const ::peony::delpoy::models::Task& Recipe::tasks(int index) const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Recipe.tasks)
  return _internal_tasks(index);
}
inline ::peony::delpoy::models::Task* Recipe::_internal_add_tasks() {
  return tasks_.Add();
}
inline ::peony::delpoy::models::Task* Recipe::add_tasks() {
  // @@protoc_insertion_point(field_add:peony.delpoy.models.Recipe.tasks)
  return _internal_add_tasks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::delpoy::models::Task >&
Recipe::tasks() const {
  // @@protoc_insertion_point(field_list:peony.delpoy.models.Recipe.tasks)
  return tasks_;
}

// -------------------------------------------------------------------

// Ssh

// string host = 1;
inline void Ssh::clear_host() {
  host_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Ssh::host() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Ssh.host)
  return _internal_host();
}
inline void Ssh::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Ssh.host)
}
inline std::string* Ssh::mutable_host() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Ssh.host)
  return _internal_mutable_host();
}
inline const std::string& Ssh::_internal_host() const {
  return host_.Get();
}
inline void Ssh::_internal_set_host(const std::string& value) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Ssh::set_host(std::string&& value) {
  
  host_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Ssh.host)
}
inline void Ssh::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Ssh.host)
}
inline void Ssh::set_host(const char* value,
    size_t size) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Ssh.host)
}
inline std::string* Ssh::_internal_mutable_host() {
  
  return host_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Ssh::release_host() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Ssh.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Ssh::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Ssh.host)
}

// int32 port = 2;
inline void Ssh::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Ssh::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Ssh::port() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Ssh.port)
  return _internal_port();
}
inline void Ssh::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void Ssh::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Ssh.port)
}

// string user = 3;
inline void Ssh::clear_user() {
  user_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Ssh::user() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Ssh.user)
  return _internal_user();
}
inline void Ssh::set_user(const std::string& value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Ssh.user)
}
inline std::string* Ssh::mutable_user() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Ssh.user)
  return _internal_mutable_user();
}
inline const std::string& Ssh::_internal_user() const {
  return user_.Get();
}
inline void Ssh::_internal_set_user(const std::string& value) {
  
  user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Ssh::set_user(std::string&& value) {
  
  user_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Ssh.user)
}
inline void Ssh::set_user(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Ssh.user)
}
inline void Ssh::set_user(const char* value,
    size_t size) {
  
  user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Ssh.user)
}
inline std::string* Ssh::_internal_mutable_user() {
  
  return user_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Ssh::release_user() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Ssh.user)
  return user_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Ssh::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Ssh.user)
}

// string key = 4;
inline void Ssh::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Ssh::key() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Ssh.key)
  return _internal_key();
}
inline void Ssh::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Ssh.key)
}
inline std::string* Ssh::mutable_key() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Ssh.key)
  return _internal_mutable_key();
}
inline const std::string& Ssh::_internal_key() const {
  return key_.Get();
}
inline void Ssh::_internal_set_key(const std::string& value) {
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Ssh::set_key(std::string&& value) {
  
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Ssh.key)
}
inline void Ssh::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Ssh.key)
}
inline void Ssh::set_key(const char* value,
    size_t size) {
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Ssh.key)
}
inline std::string* Ssh::_internal_mutable_key() {
  
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Ssh::release_key() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Ssh.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Ssh::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Ssh.key)
}

// -------------------------------------------------------------------

// Group

// string name = 1;
inline void Group::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Group::name() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Group.name)
  return _internal_name();
}
inline void Group::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Group.name)
}
inline std::string* Group::mutable_name() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Group.name)
  return _internal_mutable_name();
}
inline const std::string& Group::_internal_name() const {
  return name_.Get();
}
inline void Group::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Group::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Group.name)
}
inline void Group::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Group.name)
}
inline void Group::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Group.name)
}
inline std::string* Group::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Group::release_name() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Group.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Group::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Group.name)
}

// repeated string hosts = 2;
inline int Group::_internal_hosts_size() const {
  return hosts_.size();
}
inline int Group::hosts_size() const {
  return _internal_hosts_size();
}
inline void Group::clear_hosts() {
  hosts_.Clear();
}
inline std::string* Group::add_hosts() {
  // @@protoc_insertion_point(field_add_mutable:peony.delpoy.models.Group.hosts)
  return _internal_add_hosts();
}
inline const std::string& Group::_internal_hosts(int index) const {
  return hosts_.Get(index);
}
inline const std::string& Group::hosts(int index) const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Group.hosts)
  return _internal_hosts(index);
}
inline std::string* Group::mutable_hosts(int index) {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Group.hosts)
  return hosts_.Mutable(index);
}
inline void Group::set_hosts(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Group.hosts)
  hosts_.Mutable(index)->assign(value);
}
inline void Group::set_hosts(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Group.hosts)
  hosts_.Mutable(index)->assign(std::move(value));
}
inline void Group::set_hosts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Group.hosts)
}
inline void Group::set_hosts(int index, const char* value, size_t size) {
  hosts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Group.hosts)
}
inline std::string* Group::_internal_add_hosts() {
  return hosts_.Add();
}
inline void Group::add_hosts(const std::string& value) {
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:peony.delpoy.models.Group.hosts)
}
inline void Group::add_hosts(std::string&& value) {
  hosts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:peony.delpoy.models.Group.hosts)
}
inline void Group::add_hosts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:peony.delpoy.models.Group.hosts)
}
inline void Group::add_hosts(const char* value, size_t size) {
  hosts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:peony.delpoy.models.Group.hosts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Group::hosts() const {
  // @@protoc_insertion_point(field_list:peony.delpoy.models.Group.hosts)
  return hosts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Group::mutable_hosts() {
  // @@protoc_insertion_point(field_mutable_list:peony.delpoy.models.Group.hosts)
  return &hosts_;
}

// -------------------------------------------------------------------

// Inventory

// string name = 1;
inline void Inventory::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Inventory::name() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Inventory.name)
  return _internal_name();
}
inline void Inventory::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Inventory.name)
}
inline std::string* Inventory::mutable_name() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Inventory.name)
  return _internal_mutable_name();
}
inline const std::string& Inventory::_internal_name() const {
  return name_.Get();
}
inline void Inventory::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Inventory::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Inventory.name)
}
inline void Inventory::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Inventory.name)
}
inline void Inventory::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Inventory.name)
}
inline std::string* Inventory::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Inventory::release_name() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Inventory.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Inventory::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Inventory.name)
}

// repeated string groups = 2;
inline int Inventory::_internal_groups_size() const {
  return groups_.size();
}
inline int Inventory::groups_size() const {
  return _internal_groups_size();
}
inline void Inventory::clear_groups() {
  groups_.Clear();
}
inline std::string* Inventory::add_groups() {
  // @@protoc_insertion_point(field_add_mutable:peony.delpoy.models.Inventory.groups)
  return _internal_add_groups();
}
inline const std::string& Inventory::_internal_groups(int index) const {
  return groups_.Get(index);
}
inline const std::string& Inventory::groups(int index) const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Inventory.groups)
  return _internal_groups(index);
}
inline std::string* Inventory::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Inventory.groups)
  return groups_.Mutable(index);
}
inline void Inventory::set_groups(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Inventory.groups)
  groups_.Mutable(index)->assign(value);
}
inline void Inventory::set_groups(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Inventory.groups)
  groups_.Mutable(index)->assign(std::move(value));
}
inline void Inventory::set_groups(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Inventory.groups)
}
inline void Inventory::set_groups(int index, const char* value, size_t size) {
  groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Inventory.groups)
}
inline std::string* Inventory::_internal_add_groups() {
  return groups_.Add();
}
inline void Inventory::add_groups(const std::string& value) {
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:peony.delpoy.models.Inventory.groups)
}
inline void Inventory::add_groups(std::string&& value) {
  groups_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:peony.delpoy.models.Inventory.groups)
}
inline void Inventory::add_groups(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:peony.delpoy.models.Inventory.groups)
}
inline void Inventory::add_groups(const char* value, size_t size) {
  groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:peony.delpoy.models.Inventory.groups)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Inventory::groups() const {
  // @@protoc_insertion_point(field_list:peony.delpoy.models.Inventory.groups)
  return groups_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Inventory::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:peony.delpoy.models.Inventory.groups)
  return &groups_;
}

// repeated string hosts = 3;
inline int Inventory::_internal_hosts_size() const {
  return hosts_.size();
}
inline int Inventory::hosts_size() const {
  return _internal_hosts_size();
}
inline void Inventory::clear_hosts() {
  hosts_.Clear();
}
inline std::string* Inventory::add_hosts() {
  // @@protoc_insertion_point(field_add_mutable:peony.delpoy.models.Inventory.hosts)
  return _internal_add_hosts();
}
inline const std::string& Inventory::_internal_hosts(int index) const {
  return hosts_.Get(index);
}
inline const std::string& Inventory::hosts(int index) const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Inventory.hosts)
  return _internal_hosts(index);
}
inline std::string* Inventory::mutable_hosts(int index) {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Inventory.hosts)
  return hosts_.Mutable(index);
}
inline void Inventory::set_hosts(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Inventory.hosts)
  hosts_.Mutable(index)->assign(value);
}
inline void Inventory::set_hosts(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Inventory.hosts)
  hosts_.Mutable(index)->assign(std::move(value));
}
inline void Inventory::set_hosts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Inventory.hosts)
}
inline void Inventory::set_hosts(int index, const char* value, size_t size) {
  hosts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Inventory.hosts)
}
inline std::string* Inventory::_internal_add_hosts() {
  return hosts_.Add();
}
inline void Inventory::add_hosts(const std::string& value) {
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:peony.delpoy.models.Inventory.hosts)
}
inline void Inventory::add_hosts(std::string&& value) {
  hosts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:peony.delpoy.models.Inventory.hosts)
}
inline void Inventory::add_hosts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:peony.delpoy.models.Inventory.hosts)
}
inline void Inventory::add_hosts(const char* value, size_t size) {
  hosts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:peony.delpoy.models.Inventory.hosts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Inventory::hosts() const {
  // @@protoc_insertion_point(field_list:peony.delpoy.models.Inventory.hosts)
  return hosts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Inventory::mutable_hosts() {
  // @@protoc_insertion_point(field_mutable_list:peony.delpoy.models.Inventory.hosts)
  return &hosts_;
}

// -------------------------------------------------------------------

// Log

// string inventory = 1;
inline void Log::clear_inventory() {
  inventory_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Log::inventory() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Log.inventory)
  return _internal_inventory();
}
inline void Log::set_inventory(const std::string& value) {
  _internal_set_inventory(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Log.inventory)
}
inline std::string* Log::mutable_inventory() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Log.inventory)
  return _internal_mutable_inventory();
}
inline const std::string& Log::_internal_inventory() const {
  return inventory_.Get();
}
inline void Log::_internal_set_inventory(const std::string& value) {
  
  inventory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Log::set_inventory(std::string&& value) {
  
  inventory_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Log.inventory)
}
inline void Log::set_inventory(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  inventory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Log.inventory)
}
inline void Log::set_inventory(const char* value,
    size_t size) {
  
  inventory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Log.inventory)
}
inline std::string* Log::_internal_mutable_inventory() {
  
  return inventory_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Log::release_inventory() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Log.inventory)
  return inventory_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Log::set_allocated_inventory(std::string* inventory) {
  if (inventory != nullptr) {
    
  } else {
    
  }
  inventory_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), inventory,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Log.inventory)
}

// string group = 2;
inline void Log::clear_group() {
  group_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Log::group() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Log.group)
  return _internal_group();
}
inline void Log::set_group(const std::string& value) {
  _internal_set_group(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Log.group)
}
inline std::string* Log::mutable_group() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Log.group)
  return _internal_mutable_group();
}
inline const std::string& Log::_internal_group() const {
  return group_.Get();
}
inline void Log::_internal_set_group(const std::string& value) {
  
  group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Log::set_group(std::string&& value) {
  
  group_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Log.group)
}
inline void Log::set_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Log.group)
}
inline void Log::set_group(const char* value,
    size_t size) {
  
  group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Log.group)
}
inline std::string* Log::_internal_mutable_group() {
  
  return group_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Log::release_group() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Log.group)
  return group_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Log::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  group_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Log.group)
}

// string user = 3;
inline void Log::clear_user() {
  user_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Log::user() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Log.user)
  return _internal_user();
}
inline void Log::set_user(const std::string& value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Log.user)
}
inline std::string* Log::mutable_user() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Log.user)
  return _internal_mutable_user();
}
inline const std::string& Log::_internal_user() const {
  return user_.Get();
}
inline void Log::_internal_set_user(const std::string& value) {
  
  user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Log::set_user(std::string&& value) {
  
  user_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Log.user)
}
inline void Log::set_user(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Log.user)
}
inline void Log::set_user(const char* value,
    size_t size) {
  
  user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Log.user)
}
inline std::string* Log::_internal_mutable_user() {
  
  return user_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Log::release_user() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Log.user)
  return user_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Log::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Log.user)
}

// string host = 4;
inline void Log::clear_host() {
  host_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Log::host() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Log.host)
  return _internal_host();
}
inline void Log::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Log.host)
}
inline std::string* Log::mutable_host() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Log.host)
  return _internal_mutable_host();
}
inline const std::string& Log::_internal_host() const {
  return host_.Get();
}
inline void Log::_internal_set_host(const std::string& value) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Log::set_host(std::string&& value) {
  
  host_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Log.host)
}
inline void Log::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Log.host)
}
inline void Log::set_host(const char* value,
    size_t size) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Log.host)
}
inline std::string* Log::_internal_mutable_host() {
  
  return host_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Log::release_host() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Log.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Log::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Log.host)
}

// string reacipe = 5;
inline void Log::clear_reacipe() {
  reacipe_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Log::reacipe() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Log.reacipe)
  return _internal_reacipe();
}
inline void Log::set_reacipe(const std::string& value) {
  _internal_set_reacipe(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Log.reacipe)
}
inline std::string* Log::mutable_reacipe() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Log.reacipe)
  return _internal_mutable_reacipe();
}
inline const std::string& Log::_internal_reacipe() const {
  return reacipe_.Get();
}
inline void Log::_internal_set_reacipe(const std::string& value) {
  
  reacipe_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Log::set_reacipe(std::string&& value) {
  
  reacipe_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Log.reacipe)
}
inline void Log::set_reacipe(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reacipe_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Log.reacipe)
}
inline void Log::set_reacipe(const char* value,
    size_t size) {
  
  reacipe_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Log.reacipe)
}
inline std::string* Log::_internal_mutable_reacipe() {
  
  return reacipe_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Log::release_reacipe() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Log.reacipe)
  return reacipe_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Log::set_allocated_reacipe(std::string* reacipe) {
  if (reacipe != nullptr) {
    
  } else {
    
  }
  reacipe_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reacipe,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Log.reacipe)
}

// string task = 6;
inline void Log::clear_task() {
  task_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Log::task() const {
  // @@protoc_insertion_point(field_get:peony.delpoy.models.Log.task)
  return _internal_task();
}
inline void Log::set_task(const std::string& value) {
  _internal_set_task(value);
  // @@protoc_insertion_point(field_set:peony.delpoy.models.Log.task)
}
inline std::string* Log::mutable_task() {
  // @@protoc_insertion_point(field_mutable:peony.delpoy.models.Log.task)
  return _internal_mutable_task();
}
inline const std::string& Log::_internal_task() const {
  return task_.Get();
}
inline void Log::_internal_set_task(const std::string& value) {
  
  task_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Log::set_task(std::string&& value) {
  
  task_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.delpoy.models.Log.task)
}
inline void Log::set_task(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.delpoy.models.Log.task)
}
inline void Log::set_task(const char* value,
    size_t size) {
  
  task_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.delpoy.models.Log.task)
}
inline std::string* Log::_internal_mutable_task() {
  
  return task_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Log::release_task() {
  // @@protoc_insertion_point(field_release:peony.delpoy.models.Log.task)
  return task_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Log::set_allocated_task(std::string* task) {
  if (task != nullptr) {
    
  } else {
    
  }
  task_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.delpoy.models.Log.task)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace models
}  // namespace delpoy
}  // namespace peony

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_deploy_2eproto
