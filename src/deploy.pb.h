// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: deploy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_deploy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_deploy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_deploy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_deploy_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_deploy_2eproto;
namespace peony {
namespace deploy {
namespace models {
class Group;
class GroupDefaultTypeInternal;
extern GroupDefaultTypeInternal _Group_default_instance_;
class Group_EnvEntry_DoNotUse;
class Group_EnvEntry_DoNotUseDefaultTypeInternal;
extern Group_EnvEntry_DoNotUseDefaultTypeInternal _Group_EnvEntry_DoNotUse_default_instance_;
class Inventory;
class InventoryDefaultTypeInternal;
extern InventoryDefaultTypeInternal _Inventory_default_instance_;
class Inventory_EnvEntry_DoNotUse;
class Inventory_EnvEntry_DoNotUseDefaultTypeInternal;
extern Inventory_EnvEntry_DoNotUseDefaultTypeInternal _Inventory_EnvEntry_DoNotUse_default_instance_;
class Recipe;
class RecipeDefaultTypeInternal;
extern RecipeDefaultTypeInternal _Recipe_default_instance_;
class Ssh;
class SshDefaultTypeInternal;
extern SshDefaultTypeInternal _Ssh_default_instance_;
class Ssh_EnvEntry_DoNotUse;
class Ssh_EnvEntry_DoNotUseDefaultTypeInternal;
extern Ssh_EnvEntry_DoNotUseDefaultTypeInternal _Ssh_EnvEntry_DoNotUse_default_instance_;
class Task;
class TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class Task_Download;
class Task_DownloadDefaultTypeInternal;
extern Task_DownloadDefaultTypeInternal _Task_Download_default_instance_;
class Task_Script;
class Task_ScriptDefaultTypeInternal;
extern Task_ScriptDefaultTypeInternal _Task_Script_default_instance_;
class Task_Upload;
class Task_UploadDefaultTypeInternal;
extern Task_UploadDefaultTypeInternal _Task_Upload_default_instance_;
}  // namespace models
}  // namespace deploy
}  // namespace peony
PROTOBUF_NAMESPACE_OPEN
template<> ::peony::deploy::models::Group* Arena::CreateMaybeMessage<::peony::deploy::models::Group>(Arena*);
template<> ::peony::deploy::models::Group_EnvEntry_DoNotUse* Arena::CreateMaybeMessage<::peony::deploy::models::Group_EnvEntry_DoNotUse>(Arena*);
template<> ::peony::deploy::models::Inventory* Arena::CreateMaybeMessage<::peony::deploy::models::Inventory>(Arena*);
template<> ::peony::deploy::models::Inventory_EnvEntry_DoNotUse* Arena::CreateMaybeMessage<::peony::deploy::models::Inventory_EnvEntry_DoNotUse>(Arena*);
template<> ::peony::deploy::models::Recipe* Arena::CreateMaybeMessage<::peony::deploy::models::Recipe>(Arena*);
template<> ::peony::deploy::models::Ssh* Arena::CreateMaybeMessage<::peony::deploy::models::Ssh>(Arena*);
template<> ::peony::deploy::models::Ssh_EnvEntry_DoNotUse* Arena::CreateMaybeMessage<::peony::deploy::models::Ssh_EnvEntry_DoNotUse>(Arena*);
template<> ::peony::deploy::models::Task* Arena::CreateMaybeMessage<::peony::deploy::models::Task>(Arena*);
template<> ::peony::deploy::models::Task_Download* Arena::CreateMaybeMessage<::peony::deploy::models::Task_Download>(Arena*);
template<> ::peony::deploy::models::Task_Script* Arena::CreateMaybeMessage<::peony::deploy::models::Task_Script>(Arena*);
template<> ::peony::deploy::models::Task_Upload* Arena::CreateMaybeMessage<::peony::deploy::models::Task_Upload>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace peony {
namespace deploy {
namespace models {

// ===================================================================

class Task_Script PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.deploy.models.Task.Script) */ {
 public:
  inline Task_Script() : Task_Script(nullptr) {}
  virtual ~Task_Script();

  Task_Script(const Task_Script& from);
  Task_Script(Task_Script&& from) noexcept
    : Task_Script() {
    *this = ::std::move(from);
  }

  inline Task_Script& operator=(const Task_Script& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task_Script& operator=(Task_Script&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Task_Script& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Task_Script* internal_default_instance() {
    return reinterpret_cast<const Task_Script*>(
               &_Task_Script_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Task_Script& a, Task_Script& b) {
    a.Swap(&b);
  }
  inline void Swap(Task_Script* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task_Script* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Task_Script* New() const final {
    return CreateMaybeMessage<Task_Script>(nullptr);
  }

  Task_Script* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Task_Script>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Task_Script& from);
  void MergeFrom(const Task_Script& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task_Script* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.deploy.models.Task.Script";
  }
  protected:
  explicit Task_Script(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileFieldNumber = 1,
    kShellFieldNumber = 2,
  };
  // string file = 1;
  void clear_file();
  const std::string& file() const;
  void set_file(const std::string& value);
  void set_file(std::string&& value);
  void set_file(const char* value);
  void set_file(const char* value, size_t size);
  std::string* mutable_file();
  std::string* release_file();
  void set_allocated_file(std::string* file);
  private:
  const std::string& _internal_file() const;
  void _internal_set_file(const std::string& value);
  std::string* _internal_mutable_file();
  public:

  // string shell = 2;
  void clear_shell();
  const std::string& shell() const;
  void set_shell(const std::string& value);
  void set_shell(std::string&& value);
  void set_shell(const char* value);
  void set_shell(const char* value, size_t size);
  std::string* mutable_shell();
  std::string* release_shell();
  void set_allocated_shell(std::string* shell);
  private:
  const std::string& _internal_shell() const;
  void _internal_set_shell(const std::string& value);
  std::string* _internal_mutable_shell();
  public:

  // @@protoc_insertion_point(class_scope:peony.deploy.models.Task.Script)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shell_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Task_Upload PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.deploy.models.Task.Upload) */ {
 public:
  inline Task_Upload() : Task_Upload(nullptr) {}
  virtual ~Task_Upload();

  Task_Upload(const Task_Upload& from);
  Task_Upload(Task_Upload&& from) noexcept
    : Task_Upload() {
    *this = ::std::move(from);
  }

  inline Task_Upload& operator=(const Task_Upload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task_Upload& operator=(Task_Upload&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Task_Upload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Task_Upload* internal_default_instance() {
    return reinterpret_cast<const Task_Upload*>(
               &_Task_Upload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Task_Upload& a, Task_Upload& b) {
    a.Swap(&b);
  }
  inline void Swap(Task_Upload* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task_Upload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Task_Upload* New() const final {
    return CreateMaybeMessage<Task_Upload>(nullptr);
  }

  Task_Upload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Task_Upload>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Task_Upload& from);
  void MergeFrom(const Task_Upload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task_Upload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.deploy.models.Task.Upload";
  }
  protected:
  explicit Task_Upload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDestFieldNumber = 2,
    kTplFieldNumber = 3,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  void set_src(const std::string& value);
  void set_src(std::string&& value);
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  std::string* mutable_src();
  std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // string dest = 2;
  void clear_dest();
  const std::string& dest() const;
  void set_dest(const std::string& value);
  void set_dest(std::string&& value);
  void set_dest(const char* value);
  void set_dest(const char* value, size_t size);
  std::string* mutable_dest();
  std::string* release_dest();
  void set_allocated_dest(std::string* dest);
  private:
  const std::string& _internal_dest() const;
  void _internal_set_dest(const std::string& value);
  std::string* _internal_mutable_dest();
  public:

  // bool tpl = 3;
  void clear_tpl();
  bool tpl() const;
  void set_tpl(bool value);
  private:
  bool _internal_tpl() const;
  void _internal_set_tpl(bool value);
  public:

  // @@protoc_insertion_point(class_scope:peony.deploy.models.Task.Upload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_;
  bool tpl_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Task_Download PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.deploy.models.Task.Download) */ {
 public:
  inline Task_Download() : Task_Download(nullptr) {}
  virtual ~Task_Download();

  Task_Download(const Task_Download& from);
  Task_Download(Task_Download&& from) noexcept
    : Task_Download() {
    *this = ::std::move(from);
  }

  inline Task_Download& operator=(const Task_Download& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task_Download& operator=(Task_Download&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Task_Download& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Task_Download* internal_default_instance() {
    return reinterpret_cast<const Task_Download*>(
               &_Task_Download_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Task_Download& a, Task_Download& b) {
    a.Swap(&b);
  }
  inline void Swap(Task_Download* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task_Download* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Task_Download* New() const final {
    return CreateMaybeMessage<Task_Download>(nullptr);
  }

  Task_Download* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Task_Download>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Task_Download& from);
  void MergeFrom(const Task_Download& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task_Download* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.deploy.models.Task.Download";
  }
  protected:
  explicit Task_Download(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDestFieldNumber = 2,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  void set_src(const std::string& value);
  void set_src(std::string&& value);
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  std::string* mutable_src();
  std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // string dest = 2;
  void clear_dest();
  const std::string& dest() const;
  void set_dest(const std::string& value);
  void set_dest(std::string&& value);
  void set_dest(const char* value);
  void set_dest(const char* value, size_t size);
  std::string* mutable_dest();
  std::string* release_dest();
  void set_allocated_dest(std::string* dest);
  private:
  const std::string& _internal_dest() const;
  void _internal_set_dest(const std::string& value);
  std::string* _internal_mutable_dest();
  public:

  // @@protoc_insertion_point(class_scope:peony.deploy.models.Task.Download)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Task PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.deploy.models.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  virtual ~Task();

  Task(const Task& from);
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Task& default_instance();

  enum PayloadCase {
    kScript = 2,
    kUpload = 3,
    kDownload = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Task* New() const final {
    return CreateMaybeMessage<Task>(nullptr);
  }

  Task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.deploy.models.Task";
  }
  protected:
  explicit Task(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Task_Script Script;
  typedef Task_Upload Upload;
  typedef Task_Download Download;

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 5,
    kHostsFieldNumber = 6,
    kNameFieldNumber = 1,
    kScriptFieldNumber = 2,
    kUploadFieldNumber = 3,
    kDownloadFieldNumber = 4,
  };
  // repeated string groups = 5;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  const std::string& groups(int index) const;
  std::string* mutable_groups(int index);
  void set_groups(int index, const std::string& value);
  void set_groups(int index, std::string&& value);
  void set_groups(int index, const char* value);
  void set_groups(int index, const char* value, size_t size);
  std::string* add_groups();
  void add_groups(const std::string& value);
  void add_groups(std::string&& value);
  void add_groups(const char* value);
  void add_groups(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& groups() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_groups();
  private:
  const std::string& _internal_groups(int index) const;
  std::string* _internal_add_groups();
  public:

  // repeated string hosts = 6;
  int hosts_size() const;
  private:
  int _internal_hosts_size() const;
  public:
  void clear_hosts();
  const std::string& hosts(int index) const;
  std::string* mutable_hosts(int index);
  void set_hosts(int index, const std::string& value);
  void set_hosts(int index, std::string&& value);
  void set_hosts(int index, const char* value);
  void set_hosts(int index, const char* value, size_t size);
  std::string* add_hosts();
  void add_hosts(const std::string& value);
  void add_hosts(std::string&& value);
  void add_hosts(const char* value);
  void add_hosts(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hosts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hosts();
  private:
  const std::string& _internal_hosts(int index) const;
  std::string* _internal_add_hosts();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .peony.deploy.models.Task.Script script = 2;
  bool has_script() const;
  private:
  bool _internal_has_script() const;
  public:
  void clear_script();
  const ::peony::deploy::models::Task_Script& script() const;
  ::peony::deploy::models::Task_Script* release_script();
  ::peony::deploy::models::Task_Script* mutable_script();
  void set_allocated_script(::peony::deploy::models::Task_Script* script);
  private:
  const ::peony::deploy::models::Task_Script& _internal_script() const;
  ::peony::deploy::models::Task_Script* _internal_mutable_script();
  public:
  void unsafe_arena_set_allocated_script(
      ::peony::deploy::models::Task_Script* script);
  ::peony::deploy::models::Task_Script* unsafe_arena_release_script();

  // .peony.deploy.models.Task.Upload upload = 3;
  bool has_upload() const;
  private:
  bool _internal_has_upload() const;
  public:
  void clear_upload();
  const ::peony::deploy::models::Task_Upload& upload() const;
  ::peony::deploy::models::Task_Upload* release_upload();
  ::peony::deploy::models::Task_Upload* mutable_upload();
  void set_allocated_upload(::peony::deploy::models::Task_Upload* upload);
  private:
  const ::peony::deploy::models::Task_Upload& _internal_upload() const;
  ::peony::deploy::models::Task_Upload* _internal_mutable_upload();
  public:
  void unsafe_arena_set_allocated_upload(
      ::peony::deploy::models::Task_Upload* upload);
  ::peony::deploy::models::Task_Upload* unsafe_arena_release_upload();

  // .peony.deploy.models.Task.Download download = 4;
  bool has_download() const;
  private:
  bool _internal_has_download() const;
  public:
  void clear_download();
  const ::peony::deploy::models::Task_Download& download() const;
  ::peony::deploy::models::Task_Download* release_download();
  ::peony::deploy::models::Task_Download* mutable_download();
  void set_allocated_download(::peony::deploy::models::Task_Download* download);
  private:
  const ::peony::deploy::models::Task_Download& _internal_download() const;
  ::peony::deploy::models::Task_Download* _internal_mutable_download();
  public:
  void unsafe_arena_set_allocated_download(
      ::peony::deploy::models::Task_Download* download);
  ::peony::deploy::models::Task_Download* unsafe_arena_release_download();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:peony.deploy.models.Task)
 private:
  class _Internal;
  void set_has_script();
  void set_has_upload();
  void set_has_download();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> groups_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hosts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  union PayloadUnion {
    PayloadUnion() {}
    ::peony::deploy::models::Task_Script* script_;
    ::peony::deploy::models::Task_Upload* upload_;
    ::peony::deploy::models::Task_Download* download_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Recipe PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.deploy.models.Recipe) */ {
 public:
  inline Recipe() : Recipe(nullptr) {}
  virtual ~Recipe();

  Recipe(const Recipe& from);
  Recipe(Recipe&& from) noexcept
    : Recipe() {
    *this = ::std::move(from);
  }

  inline Recipe& operator=(const Recipe& from) {
    CopyFrom(from);
    return *this;
  }
  inline Recipe& operator=(Recipe&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Recipe& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Recipe* internal_default_instance() {
    return reinterpret_cast<const Recipe*>(
               &_Recipe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Recipe& a, Recipe& b) {
    a.Swap(&b);
  }
  inline void Swap(Recipe* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Recipe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Recipe* New() const final {
    return CreateMaybeMessage<Recipe>(nullptr);
  }

  Recipe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Recipe>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Recipe& from);
  void MergeFrom(const Recipe& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Recipe* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.deploy.models.Recipe";
  }
  protected:
  explicit Recipe(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .peony.deploy.models.Task tasks = 2;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;
  public:
  void clear_tasks();
  ::peony::deploy::models::Task* mutable_tasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::deploy::models::Task >*
      mutable_tasks();
  private:
  const ::peony::deploy::models::Task& _internal_tasks(int index) const;
  ::peony::deploy::models::Task* _internal_add_tasks();
  public:
  const ::peony::deploy::models::Task& tasks(int index) const;
  ::peony::deploy::models::Task* add_tasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::deploy::models::Task >&
      tasks() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:peony.deploy.models.Recipe)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::deploy::models::Task > tasks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Ssh_EnvEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Ssh_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Ssh_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Ssh_EnvEntry_DoNotUse();
  explicit Ssh_EnvEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Ssh_EnvEntry_DoNotUse& other);
  static const Ssh_EnvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Ssh_EnvEntry_DoNotUse*>(&_Ssh_EnvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "peony.deploy.models.Ssh.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "peony.deploy.models.Ssh.EnvEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[5];
  }

  public:
};

// -------------------------------------------------------------------

class Ssh PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.deploy.models.Ssh) */ {
 public:
  inline Ssh() : Ssh(nullptr) {}
  virtual ~Ssh();

  Ssh(const Ssh& from);
  Ssh(Ssh&& from) noexcept
    : Ssh() {
    *this = ::std::move(from);
  }

  inline Ssh& operator=(const Ssh& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ssh& operator=(Ssh&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Ssh& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ssh* internal_default_instance() {
    return reinterpret_cast<const Ssh*>(
               &_Ssh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Ssh& a, Ssh& b) {
    a.Swap(&b);
  }
  inline void Swap(Ssh* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ssh* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ssh* New() const final {
    return CreateMaybeMessage<Ssh>(nullptr);
  }

  Ssh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ssh>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Ssh& from);
  void MergeFrom(const Ssh& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ssh* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.deploy.models.Ssh";
  }
  protected:
  explicit Ssh(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEnvFieldNumber = 5,
    kHostFieldNumber = 1,
    kUserFieldNumber = 3,
    kKeyFieldNumber = 4,
    kPortFieldNumber = 2,
  };
  // map<string, string> env = 5;
  int env_size() const;
  private:
  int _internal_env_size() const;
  public:
  void clear_env();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_env();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_env();

  // string host = 1;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string user = 3;
  void clear_user();
  const std::string& user() const;
  void set_user(const std::string& value);
  void set_user(std::string&& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  std::string* mutable_user();
  std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string key = 4;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // int32 port = 2;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:peony.deploy.models.Ssh)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Ssh_EnvEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > env_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Group_EnvEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Group_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Group_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Group_EnvEntry_DoNotUse();
  explicit Group_EnvEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Group_EnvEntry_DoNotUse& other);
  static const Group_EnvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Group_EnvEntry_DoNotUse*>(&_Group_EnvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "peony.deploy.models.Group.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "peony.deploy.models.Group.EnvEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[7];
  }

  public:
};

// -------------------------------------------------------------------

class Group PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.deploy.models.Group) */ {
 public:
  inline Group() : Group(nullptr) {}
  virtual ~Group();

  Group(const Group& from);
  Group(Group&& from) noexcept
    : Group() {
    *this = ::std::move(from);
  }

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }
  inline Group& operator=(Group&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Group& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Group* internal_default_instance() {
    return reinterpret_cast<const Group*>(
               &_Group_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Group& a, Group& b) {
    a.Swap(&b);
  }
  inline void Swap(Group* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Group* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Group* New() const final {
    return CreateMaybeMessage<Group>(nullptr);
  }

  Group* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Group>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Group* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.deploy.models.Group";
  }
  protected:
  explicit Group(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kHostsFieldNumber = 2,
    kEnvFieldNumber = 3,
    kNameFieldNumber = 1,
  };
  // repeated string hosts = 2;
  int hosts_size() const;
  private:
  int _internal_hosts_size() const;
  public:
  void clear_hosts();
  const std::string& hosts(int index) const;
  std::string* mutable_hosts(int index);
  void set_hosts(int index, const std::string& value);
  void set_hosts(int index, std::string&& value);
  void set_hosts(int index, const char* value);
  void set_hosts(int index, const char* value, size_t size);
  std::string* add_hosts();
  void add_hosts(const std::string& value);
  void add_hosts(std::string&& value);
  void add_hosts(const char* value);
  void add_hosts(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hosts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hosts();
  private:
  const std::string& _internal_hosts(int index) const;
  std::string* _internal_add_hosts();
  public:

  // map<string, string> env = 3;
  int env_size() const;
  private:
  int _internal_env_size() const;
  public:
  void clear_env();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_env();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_env();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:peony.deploy.models.Group)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hosts_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Group_EnvEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > env_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// -------------------------------------------------------------------

class Inventory_EnvEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Inventory_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Inventory_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Inventory_EnvEntry_DoNotUse();
  explicit Inventory_EnvEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Inventory_EnvEntry_DoNotUse& other);
  static const Inventory_EnvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Inventory_EnvEntry_DoNotUse*>(&_Inventory_EnvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "peony.deploy.models.Inventory.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "peony.deploy.models.Inventory.EnvEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[9];
  }

  public:
};

// -------------------------------------------------------------------

class Inventory PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:peony.deploy.models.Inventory) */ {
 public:
  inline Inventory() : Inventory(nullptr) {}
  virtual ~Inventory();

  Inventory(const Inventory& from);
  Inventory(Inventory&& from) noexcept
    : Inventory() {
    *this = ::std::move(from);
  }

  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inventory& operator=(Inventory&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Inventory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Inventory* internal_default_instance() {
    return reinterpret_cast<const Inventory*>(
               &_Inventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Inventory& a, Inventory& b) {
    a.Swap(&b);
  }
  inline void Swap(Inventory* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Inventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Inventory* New() const final {
    return CreateMaybeMessage<Inventory>(nullptr);
  }

  Inventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Inventory>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Inventory& from);
  void MergeFrom(const Inventory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Inventory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "peony.deploy.models.Inventory";
  }
  protected:
  explicit Inventory(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_deploy_2eproto);
    return ::descriptor_table_deploy_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 2,
    kHostsFieldNumber = 3,
    kEnvFieldNumber = 4,
    kNameFieldNumber = 1,
  };
  // repeated .peony.deploy.models.Group groups = 2;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  ::peony::deploy::models::Group* mutable_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::deploy::models::Group >*
      mutable_groups();
  private:
  const ::peony::deploy::models::Group& _internal_groups(int index) const;
  ::peony::deploy::models::Group* _internal_add_groups();
  public:
  const ::peony::deploy::models::Group& groups(int index) const;
  ::peony::deploy::models::Group* add_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::deploy::models::Group >&
      groups() const;

  // repeated string hosts = 3;
  int hosts_size() const;
  private:
  int _internal_hosts_size() const;
  public:
  void clear_hosts();
  const std::string& hosts(int index) const;
  std::string* mutable_hosts(int index);
  void set_hosts(int index, const std::string& value);
  void set_hosts(int index, std::string&& value);
  void set_hosts(int index, const char* value);
  void set_hosts(int index, const char* value, size_t size);
  std::string* add_hosts();
  void add_hosts(const std::string& value);
  void add_hosts(std::string&& value);
  void add_hosts(const char* value);
  void add_hosts(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hosts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hosts();
  private:
  const std::string& _internal_hosts(int index) const;
  std::string* _internal_add_hosts();
  public:

  // map<string, string> env = 4;
  int env_size() const;
  private:
  int _internal_env_size() const;
  public:
  void clear_env();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_env();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_env();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:peony.deploy.models.Inventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::deploy::models::Group > groups_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hosts_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Inventory_EnvEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > env_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deploy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Task_Script

// string file = 1;
inline void Task_Script::clear_file() {
  file_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Task_Script::file() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Task.Script.file)
  return _internal_file();
}
inline void Task_Script::set_file(const std::string& value) {
  _internal_set_file(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Task.Script.file)
}
inline std::string* Task_Script::mutable_file() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Task.Script.file)
  return _internal_mutable_file();
}
inline const std::string& Task_Script::_internal_file() const {
  return file_.Get();
}
inline void Task_Script::_internal_set_file(const std::string& value) {
  
  file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Task_Script::set_file(std::string&& value) {
  
  file_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.deploy.models.Task.Script.file)
}
inline void Task_Script::set_file(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Task.Script.file)
}
inline void Task_Script::set_file(const char* value,
    size_t size) {
  
  file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Task.Script.file)
}
inline std::string* Task_Script::_internal_mutable_file() {
  
  return file_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Task_Script::release_file() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Task.Script.file)
  return file_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Task_Script::set_allocated_file(std::string* file) {
  if (file != nullptr) {
    
  } else {
    
  }
  file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.deploy.models.Task.Script.file)
}

// string shell = 2;
inline void Task_Script::clear_shell() {
  shell_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Task_Script::shell() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Task.Script.shell)
  return _internal_shell();
}
inline void Task_Script::set_shell(const std::string& value) {
  _internal_set_shell(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Task.Script.shell)
}
inline std::string* Task_Script::mutable_shell() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Task.Script.shell)
  return _internal_mutable_shell();
}
inline const std::string& Task_Script::_internal_shell() const {
  return shell_.Get();
}
inline void Task_Script::_internal_set_shell(const std::string& value) {
  
  shell_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Task_Script::set_shell(std::string&& value) {
  
  shell_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.deploy.models.Task.Script.shell)
}
inline void Task_Script::set_shell(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  shell_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Task.Script.shell)
}
inline void Task_Script::set_shell(const char* value,
    size_t size) {
  
  shell_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Task.Script.shell)
}
inline std::string* Task_Script::_internal_mutable_shell() {
  
  return shell_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Task_Script::release_shell() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Task.Script.shell)
  return shell_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Task_Script::set_allocated_shell(std::string* shell) {
  if (shell != nullptr) {
    
  } else {
    
  }
  shell_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shell,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.deploy.models.Task.Script.shell)
}

// -------------------------------------------------------------------

// Task_Upload

// string src = 1;
inline void Task_Upload::clear_src() {
  src_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Task_Upload::src() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Task.Upload.src)
  return _internal_src();
}
inline void Task_Upload::set_src(const std::string& value) {
  _internal_set_src(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Task.Upload.src)
}
inline std::string* Task_Upload::mutable_src() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Task.Upload.src)
  return _internal_mutable_src();
}
inline const std::string& Task_Upload::_internal_src() const {
  return src_.Get();
}
inline void Task_Upload::_internal_set_src(const std::string& value) {
  
  src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Task_Upload::set_src(std::string&& value) {
  
  src_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.deploy.models.Task.Upload.src)
}
inline void Task_Upload::set_src(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Task.Upload.src)
}
inline void Task_Upload::set_src(const char* value,
    size_t size) {
  
  src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Task.Upload.src)
}
inline std::string* Task_Upload::_internal_mutable_src() {
  
  return src_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Task_Upload::release_src() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Task.Upload.src)
  return src_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Task_Upload::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  src_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.deploy.models.Task.Upload.src)
}

// string dest = 2;
inline void Task_Upload::clear_dest() {
  dest_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Task_Upload::dest() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Task.Upload.dest)
  return _internal_dest();
}
inline void Task_Upload::set_dest(const std::string& value) {
  _internal_set_dest(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Task.Upload.dest)
}
inline std::string* Task_Upload::mutable_dest() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Task.Upload.dest)
  return _internal_mutable_dest();
}
inline const std::string& Task_Upload::_internal_dest() const {
  return dest_.Get();
}
inline void Task_Upload::_internal_set_dest(const std::string& value) {
  
  dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Task_Upload::set_dest(std::string&& value) {
  
  dest_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.deploy.models.Task.Upload.dest)
}
inline void Task_Upload::set_dest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Task.Upload.dest)
}
inline void Task_Upload::set_dest(const char* value,
    size_t size) {
  
  dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Task.Upload.dest)
}
inline std::string* Task_Upload::_internal_mutable_dest() {
  
  return dest_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Task_Upload::release_dest() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Task.Upload.dest)
  return dest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Task_Upload::set_allocated_dest(std::string* dest) {
  if (dest != nullptr) {
    
  } else {
    
  }
  dest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dest,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.deploy.models.Task.Upload.dest)
}

// bool tpl = 3;
inline void Task_Upload::clear_tpl() {
  tpl_ = false;
}
inline bool Task_Upload::_internal_tpl() const {
  return tpl_;
}
inline bool Task_Upload::tpl() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Task.Upload.tpl)
  return _internal_tpl();
}
inline void Task_Upload::_internal_set_tpl(bool value) {
  
  tpl_ = value;
}
inline void Task_Upload::set_tpl(bool value) {
  _internal_set_tpl(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Task.Upload.tpl)
}

// -------------------------------------------------------------------

// Task_Download

// string src = 1;
inline void Task_Download::clear_src() {
  src_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Task_Download::src() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Task.Download.src)
  return _internal_src();
}
inline void Task_Download::set_src(const std::string& value) {
  _internal_set_src(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Task.Download.src)
}
inline std::string* Task_Download::mutable_src() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Task.Download.src)
  return _internal_mutable_src();
}
inline const std::string& Task_Download::_internal_src() const {
  return src_.Get();
}
inline void Task_Download::_internal_set_src(const std::string& value) {
  
  src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Task_Download::set_src(std::string&& value) {
  
  src_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.deploy.models.Task.Download.src)
}
inline void Task_Download::set_src(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Task.Download.src)
}
inline void Task_Download::set_src(const char* value,
    size_t size) {
  
  src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Task.Download.src)
}
inline std::string* Task_Download::_internal_mutable_src() {
  
  return src_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Task_Download::release_src() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Task.Download.src)
  return src_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Task_Download::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  src_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.deploy.models.Task.Download.src)
}

// string dest = 2;
inline void Task_Download::clear_dest() {
  dest_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Task_Download::dest() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Task.Download.dest)
  return _internal_dest();
}
inline void Task_Download::set_dest(const std::string& value) {
  _internal_set_dest(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Task.Download.dest)
}
inline std::string* Task_Download::mutable_dest() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Task.Download.dest)
  return _internal_mutable_dest();
}
inline const std::string& Task_Download::_internal_dest() const {
  return dest_.Get();
}
inline void Task_Download::_internal_set_dest(const std::string& value) {
  
  dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Task_Download::set_dest(std::string&& value) {
  
  dest_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.deploy.models.Task.Download.dest)
}
inline void Task_Download::set_dest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Task.Download.dest)
}
inline void Task_Download::set_dest(const char* value,
    size_t size) {
  
  dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Task.Download.dest)
}
inline std::string* Task_Download::_internal_mutable_dest() {
  
  return dest_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Task_Download::release_dest() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Task.Download.dest)
  return dest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Task_Download::set_allocated_dest(std::string* dest) {
  if (dest != nullptr) {
    
  } else {
    
  }
  dest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dest,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.deploy.models.Task.Download.dest)
}

// -------------------------------------------------------------------

// Task

// string name = 1;
inline void Task::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Task::name() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Task.name)
  return _internal_name();
}
inline void Task::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Task.name)
}
inline std::string* Task::mutable_name() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Task.name)
  return _internal_mutable_name();
}
inline const std::string& Task::_internal_name() const {
  return name_.Get();
}
inline void Task::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Task::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.deploy.models.Task.name)
}
inline void Task::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Task.name)
}
inline void Task::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Task.name)
}
inline std::string* Task::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Task::release_name() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Task.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Task::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.deploy.models.Task.name)
}

// .peony.deploy.models.Task.Script script = 2;
inline bool Task::_internal_has_script() const {
  return payload_case() == kScript;
}
inline bool Task::has_script() const {
  return _internal_has_script();
}
inline void Task::set_has_script() {
  _oneof_case_[0] = kScript;
}
inline void Task::clear_script() {
  if (_internal_has_script()) {
    if (GetArena() == nullptr) {
      delete payload_.script_;
    }
    clear_has_payload();
  }
}
inline ::peony::deploy::models::Task_Script* Task::release_script() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Task.script)
  if (_internal_has_script()) {
    clear_has_payload();
      ::peony::deploy::models::Task_Script* temp = payload_.script_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.script_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::peony::deploy::models::Task_Script& Task::_internal_script() const {
  return _internal_has_script()
      ? *payload_.script_
      : *reinterpret_cast< ::peony::deploy::models::Task_Script*>(&::peony::deploy::models::_Task_Script_default_instance_);
}
inline const ::peony::deploy::models::Task_Script& Task::script() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Task.script)
  return _internal_script();
}
inline ::peony::deploy::models::Task_Script* Task::unsafe_arena_release_script() {
  // @@protoc_insertion_point(field_unsafe_arena_release:peony.deploy.models.Task.script)
  if (_internal_has_script()) {
    clear_has_payload();
    ::peony::deploy::models::Task_Script* temp = payload_.script_;
    payload_.script_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Task::unsafe_arena_set_allocated_script(::peony::deploy::models::Task_Script* script) {
  clear_payload();
  if (script) {
    set_has_script();
    payload_.script_ = script;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:peony.deploy.models.Task.script)
}
inline ::peony::deploy::models::Task_Script* Task::_internal_mutable_script() {
  if (!_internal_has_script()) {
    clear_payload();
    set_has_script();
    payload_.script_ = CreateMaybeMessage< ::peony::deploy::models::Task_Script >(GetArena());
  }
  return payload_.script_;
}
inline ::peony::deploy::models::Task_Script* Task::mutable_script() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Task.script)
  return _internal_mutable_script();
}

// .peony.deploy.models.Task.Upload upload = 3;
inline bool Task::_internal_has_upload() const {
  return payload_case() == kUpload;
}
inline bool Task::has_upload() const {
  return _internal_has_upload();
}
inline void Task::set_has_upload() {
  _oneof_case_[0] = kUpload;
}
inline void Task::clear_upload() {
  if (_internal_has_upload()) {
    if (GetArena() == nullptr) {
      delete payload_.upload_;
    }
    clear_has_payload();
  }
}
inline ::peony::deploy::models::Task_Upload* Task::release_upload() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Task.upload)
  if (_internal_has_upload()) {
    clear_has_payload();
      ::peony::deploy::models::Task_Upload* temp = payload_.upload_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.upload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::peony::deploy::models::Task_Upload& Task::_internal_upload() const {
  return _internal_has_upload()
      ? *payload_.upload_
      : *reinterpret_cast< ::peony::deploy::models::Task_Upload*>(&::peony::deploy::models::_Task_Upload_default_instance_);
}
inline const ::peony::deploy::models::Task_Upload& Task::upload() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Task.upload)
  return _internal_upload();
}
inline ::peony::deploy::models::Task_Upload* Task::unsafe_arena_release_upload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:peony.deploy.models.Task.upload)
  if (_internal_has_upload()) {
    clear_has_payload();
    ::peony::deploy::models::Task_Upload* temp = payload_.upload_;
    payload_.upload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Task::unsafe_arena_set_allocated_upload(::peony::deploy::models::Task_Upload* upload) {
  clear_payload();
  if (upload) {
    set_has_upload();
    payload_.upload_ = upload;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:peony.deploy.models.Task.upload)
}
inline ::peony::deploy::models::Task_Upload* Task::_internal_mutable_upload() {
  if (!_internal_has_upload()) {
    clear_payload();
    set_has_upload();
    payload_.upload_ = CreateMaybeMessage< ::peony::deploy::models::Task_Upload >(GetArena());
  }
  return payload_.upload_;
}
inline ::peony::deploy::models::Task_Upload* Task::mutable_upload() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Task.upload)
  return _internal_mutable_upload();
}

// .peony.deploy.models.Task.Download download = 4;
inline bool Task::_internal_has_download() const {
  return payload_case() == kDownload;
}
inline bool Task::has_download() const {
  return _internal_has_download();
}
inline void Task::set_has_download() {
  _oneof_case_[0] = kDownload;
}
inline void Task::clear_download() {
  if (_internal_has_download()) {
    if (GetArena() == nullptr) {
      delete payload_.download_;
    }
    clear_has_payload();
  }
}
inline ::peony::deploy::models::Task_Download* Task::release_download() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Task.download)
  if (_internal_has_download()) {
    clear_has_payload();
      ::peony::deploy::models::Task_Download* temp = payload_.download_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.download_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::peony::deploy::models::Task_Download& Task::_internal_download() const {
  return _internal_has_download()
      ? *payload_.download_
      : *reinterpret_cast< ::peony::deploy::models::Task_Download*>(&::peony::deploy::models::_Task_Download_default_instance_);
}
inline const ::peony::deploy::models::Task_Download& Task::download() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Task.download)
  return _internal_download();
}
inline ::peony::deploy::models::Task_Download* Task::unsafe_arena_release_download() {
  // @@protoc_insertion_point(field_unsafe_arena_release:peony.deploy.models.Task.download)
  if (_internal_has_download()) {
    clear_has_payload();
    ::peony::deploy::models::Task_Download* temp = payload_.download_;
    payload_.download_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Task::unsafe_arena_set_allocated_download(::peony::deploy::models::Task_Download* download) {
  clear_payload();
  if (download) {
    set_has_download();
    payload_.download_ = download;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:peony.deploy.models.Task.download)
}
inline ::peony::deploy::models::Task_Download* Task::_internal_mutable_download() {
  if (!_internal_has_download()) {
    clear_payload();
    set_has_download();
    payload_.download_ = CreateMaybeMessage< ::peony::deploy::models::Task_Download >(GetArena());
  }
  return payload_.download_;
}
inline ::peony::deploy::models::Task_Download* Task::mutable_download() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Task.download)
  return _internal_mutable_download();
}

// repeated string groups = 5;
inline int Task::_internal_groups_size() const {
  return groups_.size();
}
inline int Task::groups_size() const {
  return _internal_groups_size();
}
inline void Task::clear_groups() {
  groups_.Clear();
}
inline std::string* Task::add_groups() {
  // @@protoc_insertion_point(field_add_mutable:peony.deploy.models.Task.groups)
  return _internal_add_groups();
}
inline const std::string& Task::_internal_groups(int index) const {
  return groups_.Get(index);
}
inline const std::string& Task::groups(int index) const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Task.groups)
  return _internal_groups(index);
}
inline std::string* Task::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Task.groups)
  return groups_.Mutable(index);
}
inline void Task::set_groups(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:peony.deploy.models.Task.groups)
  groups_.Mutable(index)->assign(value);
}
inline void Task::set_groups(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:peony.deploy.models.Task.groups)
  groups_.Mutable(index)->assign(std::move(value));
}
inline void Task::set_groups(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Task.groups)
}
inline void Task::set_groups(int index, const char* value, size_t size) {
  groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Task.groups)
}
inline std::string* Task::_internal_add_groups() {
  return groups_.Add();
}
inline void Task::add_groups(const std::string& value) {
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:peony.deploy.models.Task.groups)
}
inline void Task::add_groups(std::string&& value) {
  groups_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:peony.deploy.models.Task.groups)
}
inline void Task::add_groups(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:peony.deploy.models.Task.groups)
}
inline void Task::add_groups(const char* value, size_t size) {
  groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:peony.deploy.models.Task.groups)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Task::groups() const {
  // @@protoc_insertion_point(field_list:peony.deploy.models.Task.groups)
  return groups_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Task::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:peony.deploy.models.Task.groups)
  return &groups_;
}

// repeated string hosts = 6;
inline int Task::_internal_hosts_size() const {
  return hosts_.size();
}
inline int Task::hosts_size() const {
  return _internal_hosts_size();
}
inline void Task::clear_hosts() {
  hosts_.Clear();
}
inline std::string* Task::add_hosts() {
  // @@protoc_insertion_point(field_add_mutable:peony.deploy.models.Task.hosts)
  return _internal_add_hosts();
}
inline const std::string& Task::_internal_hosts(int index) const {
  return hosts_.Get(index);
}
inline const std::string& Task::hosts(int index) const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Task.hosts)
  return _internal_hosts(index);
}
inline std::string* Task::mutable_hosts(int index) {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Task.hosts)
  return hosts_.Mutable(index);
}
inline void Task::set_hosts(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:peony.deploy.models.Task.hosts)
  hosts_.Mutable(index)->assign(value);
}
inline void Task::set_hosts(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:peony.deploy.models.Task.hosts)
  hosts_.Mutable(index)->assign(std::move(value));
}
inline void Task::set_hosts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Task.hosts)
}
inline void Task::set_hosts(int index, const char* value, size_t size) {
  hosts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Task.hosts)
}
inline std::string* Task::_internal_add_hosts() {
  return hosts_.Add();
}
inline void Task::add_hosts(const std::string& value) {
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:peony.deploy.models.Task.hosts)
}
inline void Task::add_hosts(std::string&& value) {
  hosts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:peony.deploy.models.Task.hosts)
}
inline void Task::add_hosts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:peony.deploy.models.Task.hosts)
}
inline void Task::add_hosts(const char* value, size_t size) {
  hosts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:peony.deploy.models.Task.hosts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Task::hosts() const {
  // @@protoc_insertion_point(field_list:peony.deploy.models.Task.hosts)
  return hosts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Task::mutable_hosts() {
  // @@protoc_insertion_point(field_mutable_list:peony.deploy.models.Task.hosts)
  return &hosts_;
}

inline bool Task::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Task::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Task::PayloadCase Task::payload_case() const {
  return Task::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Recipe

// string name = 1;
inline void Recipe::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Recipe::name() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Recipe.name)
  return _internal_name();
}
inline void Recipe::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Recipe.name)
}
inline std::string* Recipe::mutable_name() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Recipe.name)
  return _internal_mutable_name();
}
inline const std::string& Recipe::_internal_name() const {
  return name_.Get();
}
inline void Recipe::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Recipe::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.deploy.models.Recipe.name)
}
inline void Recipe::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Recipe.name)
}
inline void Recipe::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Recipe.name)
}
inline std::string* Recipe::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Recipe::release_name() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Recipe.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Recipe::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.deploy.models.Recipe.name)
}

// repeated .peony.deploy.models.Task tasks = 2;
inline int Recipe::_internal_tasks_size() const {
  return tasks_.size();
}
inline int Recipe::tasks_size() const {
  return _internal_tasks_size();
}
inline void Recipe::clear_tasks() {
  tasks_.Clear();
}
inline ::peony::deploy::models::Task* Recipe::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Recipe.tasks)
  return tasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::deploy::models::Task >*
Recipe::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:peony.deploy.models.Recipe.tasks)
  return &tasks_;
}
inline const ::peony::deploy::models::Task& Recipe::_internal_tasks(int index) const {
  return tasks_.Get(index);
}
inline const ::peony::deploy::models::Task& Recipe::tasks(int index) const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Recipe.tasks)
  return _internal_tasks(index);
}
inline ::peony::deploy::models::Task* Recipe::_internal_add_tasks() {
  return tasks_.Add();
}
inline ::peony::deploy::models::Task* Recipe::add_tasks() {
  // @@protoc_insertion_point(field_add:peony.deploy.models.Recipe.tasks)
  return _internal_add_tasks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::deploy::models::Task >&
Recipe::tasks() const {
  // @@protoc_insertion_point(field_list:peony.deploy.models.Recipe.tasks)
  return tasks_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Ssh

// string host = 1;
inline void Ssh::clear_host() {
  host_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Ssh::host() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Ssh.host)
  return _internal_host();
}
inline void Ssh::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Ssh.host)
}
inline std::string* Ssh::mutable_host() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Ssh.host)
  return _internal_mutable_host();
}
inline const std::string& Ssh::_internal_host() const {
  return host_.Get();
}
inline void Ssh::_internal_set_host(const std::string& value) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Ssh::set_host(std::string&& value) {
  
  host_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.deploy.models.Ssh.host)
}
inline void Ssh::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Ssh.host)
}
inline void Ssh::set_host(const char* value,
    size_t size) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Ssh.host)
}
inline std::string* Ssh::_internal_mutable_host() {
  
  return host_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Ssh::release_host() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Ssh.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Ssh::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.deploy.models.Ssh.host)
}

// int32 port = 2;
inline void Ssh::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Ssh::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Ssh::port() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Ssh.port)
  return _internal_port();
}
inline void Ssh::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void Ssh::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Ssh.port)
}

// string user = 3;
inline void Ssh::clear_user() {
  user_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Ssh::user() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Ssh.user)
  return _internal_user();
}
inline void Ssh::set_user(const std::string& value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Ssh.user)
}
inline std::string* Ssh::mutable_user() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Ssh.user)
  return _internal_mutable_user();
}
inline const std::string& Ssh::_internal_user() const {
  return user_.Get();
}
inline void Ssh::_internal_set_user(const std::string& value) {
  
  user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Ssh::set_user(std::string&& value) {
  
  user_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.deploy.models.Ssh.user)
}
inline void Ssh::set_user(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Ssh.user)
}
inline void Ssh::set_user(const char* value,
    size_t size) {
  
  user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Ssh.user)
}
inline std::string* Ssh::_internal_mutable_user() {
  
  return user_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Ssh::release_user() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Ssh.user)
  return user_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Ssh::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.deploy.models.Ssh.user)
}

// string key = 4;
inline void Ssh::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Ssh::key() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Ssh.key)
  return _internal_key();
}
inline void Ssh::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Ssh.key)
}
inline std::string* Ssh::mutable_key() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Ssh.key)
  return _internal_mutable_key();
}
inline const std::string& Ssh::_internal_key() const {
  return key_.Get();
}
inline void Ssh::_internal_set_key(const std::string& value) {
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Ssh::set_key(std::string&& value) {
  
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.deploy.models.Ssh.key)
}
inline void Ssh::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Ssh.key)
}
inline void Ssh::set_key(const char* value,
    size_t size) {
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Ssh.key)
}
inline std::string* Ssh::_internal_mutable_key() {
  
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Ssh::release_key() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Ssh.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Ssh::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.deploy.models.Ssh.key)
}

// map<string, string> env = 5;
inline int Ssh::_internal_env_size() const {
  return env_.size();
}
inline int Ssh::env_size() const {
  return _internal_env_size();
}
inline void Ssh::clear_env() {
  env_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Ssh::_internal_env() const {
  return env_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Ssh::env() const {
  // @@protoc_insertion_point(field_map:peony.deploy.models.Ssh.env)
  return _internal_env();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Ssh::_internal_mutable_env() {
  return env_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Ssh::mutable_env() {
  // @@protoc_insertion_point(field_mutable_map:peony.deploy.models.Ssh.env)
  return _internal_mutable_env();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Group

// string name = 1;
inline void Group::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Group::name() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Group.name)
  return _internal_name();
}
inline void Group::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Group.name)
}
inline std::string* Group::mutable_name() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Group.name)
  return _internal_mutable_name();
}
inline const std::string& Group::_internal_name() const {
  return name_.Get();
}
inline void Group::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Group::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.deploy.models.Group.name)
}
inline void Group::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Group.name)
}
inline void Group::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Group.name)
}
inline std::string* Group::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Group::release_name() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Group.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Group::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.deploy.models.Group.name)
}

// repeated string hosts = 2;
inline int Group::_internal_hosts_size() const {
  return hosts_.size();
}
inline int Group::hosts_size() const {
  return _internal_hosts_size();
}
inline void Group::clear_hosts() {
  hosts_.Clear();
}
inline std::string* Group::add_hosts() {
  // @@protoc_insertion_point(field_add_mutable:peony.deploy.models.Group.hosts)
  return _internal_add_hosts();
}
inline const std::string& Group::_internal_hosts(int index) const {
  return hosts_.Get(index);
}
inline const std::string& Group::hosts(int index) const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Group.hosts)
  return _internal_hosts(index);
}
inline std::string* Group::mutable_hosts(int index) {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Group.hosts)
  return hosts_.Mutable(index);
}
inline void Group::set_hosts(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:peony.deploy.models.Group.hosts)
  hosts_.Mutable(index)->assign(value);
}
inline void Group::set_hosts(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:peony.deploy.models.Group.hosts)
  hosts_.Mutable(index)->assign(std::move(value));
}
inline void Group::set_hosts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Group.hosts)
}
inline void Group::set_hosts(int index, const char* value, size_t size) {
  hosts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Group.hosts)
}
inline std::string* Group::_internal_add_hosts() {
  return hosts_.Add();
}
inline void Group::add_hosts(const std::string& value) {
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:peony.deploy.models.Group.hosts)
}
inline void Group::add_hosts(std::string&& value) {
  hosts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:peony.deploy.models.Group.hosts)
}
inline void Group::add_hosts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:peony.deploy.models.Group.hosts)
}
inline void Group::add_hosts(const char* value, size_t size) {
  hosts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:peony.deploy.models.Group.hosts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Group::hosts() const {
  // @@protoc_insertion_point(field_list:peony.deploy.models.Group.hosts)
  return hosts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Group::mutable_hosts() {
  // @@protoc_insertion_point(field_mutable_list:peony.deploy.models.Group.hosts)
  return &hosts_;
}

// map<string, string> env = 3;
inline int Group::_internal_env_size() const {
  return env_.size();
}
inline int Group::env_size() const {
  return _internal_env_size();
}
inline void Group::clear_env() {
  env_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Group::_internal_env() const {
  return env_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Group::env() const {
  // @@protoc_insertion_point(field_map:peony.deploy.models.Group.env)
  return _internal_env();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Group::_internal_mutable_env() {
  return env_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Group::mutable_env() {
  // @@protoc_insertion_point(field_mutable_map:peony.deploy.models.Group.env)
  return _internal_mutable_env();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Inventory

// string name = 1;
inline void Inventory::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Inventory::name() const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Inventory.name)
  return _internal_name();
}
inline void Inventory::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:peony.deploy.models.Inventory.name)
}
inline std::string* Inventory::mutable_name() {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Inventory.name)
  return _internal_mutable_name();
}
inline const std::string& Inventory::_internal_name() const {
  return name_.Get();
}
inline void Inventory::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Inventory::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:peony.deploy.models.Inventory.name)
}
inline void Inventory::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Inventory.name)
}
inline void Inventory::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Inventory.name)
}
inline std::string* Inventory::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Inventory::release_name() {
  // @@protoc_insertion_point(field_release:peony.deploy.models.Inventory.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Inventory::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:peony.deploy.models.Inventory.name)
}

// repeated .peony.deploy.models.Group groups = 2;
inline int Inventory::_internal_groups_size() const {
  return groups_.size();
}
inline int Inventory::groups_size() const {
  return _internal_groups_size();
}
inline void Inventory::clear_groups() {
  groups_.Clear();
}
inline ::peony::deploy::models::Group* Inventory::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Inventory.groups)
  return groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::deploy::models::Group >*
Inventory::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:peony.deploy.models.Inventory.groups)
  return &groups_;
}
inline const ::peony::deploy::models::Group& Inventory::_internal_groups(int index) const {
  return groups_.Get(index);
}
inline const ::peony::deploy::models::Group& Inventory::groups(int index) const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Inventory.groups)
  return _internal_groups(index);
}
inline ::peony::deploy::models::Group* Inventory::_internal_add_groups() {
  return groups_.Add();
}
inline ::peony::deploy::models::Group* Inventory::add_groups() {
  // @@protoc_insertion_point(field_add:peony.deploy.models.Inventory.groups)
  return _internal_add_groups();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::peony::deploy::models::Group >&
Inventory::groups() const {
  // @@protoc_insertion_point(field_list:peony.deploy.models.Inventory.groups)
  return groups_;
}

// repeated string hosts = 3;
inline int Inventory::_internal_hosts_size() const {
  return hosts_.size();
}
inline int Inventory::hosts_size() const {
  return _internal_hosts_size();
}
inline void Inventory::clear_hosts() {
  hosts_.Clear();
}
inline std::string* Inventory::add_hosts() {
  // @@protoc_insertion_point(field_add_mutable:peony.deploy.models.Inventory.hosts)
  return _internal_add_hosts();
}
inline const std::string& Inventory::_internal_hosts(int index) const {
  return hosts_.Get(index);
}
inline const std::string& Inventory::hosts(int index) const {
  // @@protoc_insertion_point(field_get:peony.deploy.models.Inventory.hosts)
  return _internal_hosts(index);
}
inline std::string* Inventory::mutable_hosts(int index) {
  // @@protoc_insertion_point(field_mutable:peony.deploy.models.Inventory.hosts)
  return hosts_.Mutable(index);
}
inline void Inventory::set_hosts(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:peony.deploy.models.Inventory.hosts)
  hosts_.Mutable(index)->assign(value);
}
inline void Inventory::set_hosts(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:peony.deploy.models.Inventory.hosts)
  hosts_.Mutable(index)->assign(std::move(value));
}
inline void Inventory::set_hosts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:peony.deploy.models.Inventory.hosts)
}
inline void Inventory::set_hosts(int index, const char* value, size_t size) {
  hosts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:peony.deploy.models.Inventory.hosts)
}
inline std::string* Inventory::_internal_add_hosts() {
  return hosts_.Add();
}
inline void Inventory::add_hosts(const std::string& value) {
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:peony.deploy.models.Inventory.hosts)
}
inline void Inventory::add_hosts(std::string&& value) {
  hosts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:peony.deploy.models.Inventory.hosts)
}
inline void Inventory::add_hosts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:peony.deploy.models.Inventory.hosts)
}
inline void Inventory::add_hosts(const char* value, size_t size) {
  hosts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:peony.deploy.models.Inventory.hosts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Inventory::hosts() const {
  // @@protoc_insertion_point(field_list:peony.deploy.models.Inventory.hosts)
  return hosts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Inventory::mutable_hosts() {
  // @@protoc_insertion_point(field_mutable_list:peony.deploy.models.Inventory.hosts)
  return &hosts_;
}

// map<string, string> env = 4;
inline int Inventory::_internal_env_size() const {
  return env_.size();
}
inline int Inventory::env_size() const {
  return _internal_env_size();
}
inline void Inventory::clear_env() {
  env_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Inventory::_internal_env() const {
  return env_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Inventory::env() const {
  // @@protoc_insertion_point(field_map:peony.deploy.models.Inventory.env)
  return _internal_env();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Inventory::_internal_mutable_env() {
  return env_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Inventory::mutable_env() {
  // @@protoc_insertion_point(field_mutable_map:peony.deploy.models.Inventory.env)
  return _internal_mutable_env();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace models
}  // namespace deploy
}  // namespace peony

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_deploy_2eproto
