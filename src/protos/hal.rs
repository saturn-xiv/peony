// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_REQUEST: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_REQUEST: u8 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REQUEST: [Request; 5] = [
    Request::NONE,
    Request::tty,
    Request::gpio_pin_get,
    Request::gpio_pin_set,
    Request::audio_play,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Request(pub u8);
#[allow(non_upper_case_globals)]
impl Request {
    pub const NONE: Self = Self(0);
    pub const tty: Self = Self(1);
    pub const gpio_pin_get: Self = Self(2);
    pub const gpio_pin_set: Self = Self(3);
    pub const audio_play: Self = Self(4);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::tty,
        Self::gpio_pin_get,
        Self::gpio_pin_set,
        Self::audio_play,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::tty => Some("tty"),
            Self::gpio_pin_get => Some("gpio_pin_get"),
            Self::gpio_pin_set => Some("gpio_pin_set"),
            Self::audio_play => Some("audio_play"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for Request {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Request {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for Request {
    type Output = Request;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Request {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Request {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Request {}
pub struct RequestUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_RESPONSE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_RESPONSE: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RESPONSE: [Response; 4] = [
    Response::NONE,
    Response::tty,
    Response::gpio_pin_get,
    Response::gpio_button_report,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Response(pub u8);
#[allow(non_upper_case_globals)]
impl Response {
    pub const NONE: Self = Self(0);
    pub const tty: Self = Self(1);
    pub const gpio_pin_get: Self = Self(2);
    pub const gpio_button_report: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::tty,
        Self::gpio_pin_get,
        Self::gpio_button_report,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::tty => Some("tty"),
            Self::gpio_pin_get => Some("gpio_pin_get"),
            Self::gpio_button_report => Some("gpio_button_report"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for Response {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Response {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for Response {
    type Output = Response;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Response {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Response {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Response {}
pub struct ResponseUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_GPIO_PRESSED_MODE: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_GPIO_PRESSED_MODE: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GPIO_PRESSED_MODE: [GpioPressedMode; 3] = [
    GpioPressedMode::Single,
    GpioPressedMode::Double,
    GpioPressedMode::Hold,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GpioPressedMode(pub u8);
#[allow(non_upper_case_globals)]
impl GpioPressedMode {
    pub const Single: Self = Self(1);
    pub const Double: Self = Self(2);
    pub const Hold: Self = Self(3);

    pub const ENUM_MIN: u8 = 1;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Single, Self::Double, Self::Hold];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Single => Some("Single"),
            Self::Double => Some("Double"),
            Self::Hold => Some("Hold"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for GpioPressedMode {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for GpioPressedMode {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for GpioPressedMode {
    type Output = GpioPressedMode;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GpioPressedMode {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for GpioPressedMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for GpioPressedMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_AUDIO_TYPE: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_AUDIO_TYPE: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AUDIO_TYPE: [AudioType; 2] = [AudioType::MP3, AudioType::WAV];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AudioType(pub u8);
#[allow(non_upper_case_globals)]
impl AudioType {
    pub const MP3: Self = Self(1);
    pub const WAV: Self = Self(2);

    pub const ENUM_MIN: u8 = 1;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::MP3, Self::WAV];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MP3 => Some("MP3"),
            Self::WAV => Some("WAV"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for AudioType {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for AudioType {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for AudioType {
    type Output = AudioType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AudioType {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for AudioType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for AudioType {}
pub enum TtyRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TtyRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TtyRequest<'a> {
    type Inner = TtyRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> TtyRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TtyRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TtyRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<TtyRequest<'bldr>> {
        let mut builder = TtyRequestBuilder::new(_fbb);
        builder.add_delay(args.delay);
        if let Some(x) = args.messages {
            builder.add_messages(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_MESSAGES: flatbuffers::VOffsetT = 6;
    pub const VT_DELAY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn name(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TtyRequest::VT_NAME, None)
            .unwrap()
    }
    #[inline]
    pub fn messages(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(TtyRequest::VT_MESSAGES, None)
            .unwrap()
    }
    #[inline]
    pub fn delay(&self) -> u64 {
        self._tab
            .get::<u64>(TtyRequest::VT_DELAY, Some(300))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for TtyRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(&"messages", Self::VT_MESSAGES, true)?
            .visit_field::<u64>(&"delay", Self::VT_DELAY, false)?
            .finish();
        Ok(())
    }
}
pub struct TtyRequestArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub messages: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub delay: u64,
}
impl<'a> Default for TtyRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        TtyRequestArgs {
            name: None,     // required field
            messages: None, // required field
            delay: 300,
        }
    }
}
pub struct TtyRequestBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TtyRequestBuilder<'a, 'b> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TtyRequest::VT_NAME, name);
    }
    #[inline]
    pub fn add_messages(
        &mut self,
        messages: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TtyRequest::VT_MESSAGES, messages);
    }
    #[inline]
    pub fn add_delay(&mut self, delay: u64) {
        self.fbb_.push_slot::<u64>(TtyRequest::VT_DELAY, delay, 300);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TtyRequestBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TtyRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TtyRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, TtyRequest::VT_NAME, "name");
        self.fbb_.required(o, TtyRequest::VT_MESSAGES, "messages");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for TtyRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("TtyRequest");
        ds.field("name", &self.name());
        ds.field("messages", &self.messages());
        ds.field("delay", &self.delay());
        ds.finish()
    }
}
pub enum TtyResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TtyResponse<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TtyResponse<'a> {
    type Inner = TtyResponse<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> TtyResponse<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TtyResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TtyResponseArgs<'args>,
    ) -> flatbuffers::WIPOffset<TtyResponse<'bldr>> {
        let mut builder = TtyResponseBuilder::new(_fbb);
        if let Some(x) = args.payload {
            builder.add_payload(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn name(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TtyResponse::VT_NAME, None)
            .unwrap()
    }
    #[inline]
    pub fn payload(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TtyResponse::VT_PAYLOAD, None)
            .unwrap()
    }
}

impl flatbuffers::Verifiable for TtyResponse<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"payload", Self::VT_PAYLOAD, true)?
            .finish();
        Ok(())
    }
}
pub struct TtyResponseArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub payload: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TtyResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        TtyResponseArgs {
            name: None,    // required field
            payload: None, // required field
        }
    }
}
pub struct TtyResponseBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TtyResponseBuilder<'a, 'b> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TtyResponse::VT_NAME, name);
    }
    #[inline]
    pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TtyResponse::VT_PAYLOAD, payload);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TtyResponseBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TtyResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TtyResponse<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, TtyResponse::VT_NAME, "name");
        self.fbb_.required(o, TtyResponse::VT_PAYLOAD, "payload");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for TtyResponse<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("TtyResponse");
        ds.field("name", &self.name());
        ds.field("payload", &self.payload());
        ds.finish()
    }
}
pub enum GpioStatusOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GpioStatus<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GpioStatus<'a> {
    type Inner = GpioStatus<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> GpioStatus<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GpioStatus { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GpioStatusArgs,
    ) -> flatbuffers::WIPOffset<GpioStatus<'bldr>> {
        let mut builder = GpioStatusBuilder::new(_fbb);
        builder.add_on(args.on);
        builder.add_id(args.id);
        builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_ON: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn id(&self) -> i8 {
        self._tab.get::<i8>(GpioStatus::VT_ID, Some(0)).unwrap()
    }
    #[inline]
    pub fn on(&self) -> bool {
        self._tab
            .get::<bool>(GpioStatus::VT_ON, Some(false))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for GpioStatus<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i8>(&"id", Self::VT_ID, false)?
            .visit_field::<bool>(&"on", Self::VT_ON, false)?
            .finish();
        Ok(())
    }
}
pub struct GpioStatusArgs {
    pub id: i8,
    pub on: bool,
}
impl<'a> Default for GpioStatusArgs {
    #[inline]
    fn default() -> Self {
        GpioStatusArgs { id: 0, on: false }
    }
}
pub struct GpioStatusBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GpioStatusBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: i8) {
        self.fbb_.push_slot::<i8>(GpioStatus::VT_ID, id, 0);
    }
    #[inline]
    pub fn add_on(&mut self, on: bool) {
        self.fbb_.push_slot::<bool>(GpioStatus::VT_ON, on, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GpioStatusBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GpioStatusBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GpioStatus<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for GpioStatus<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("GpioStatus");
        ds.field("id", &self.id());
        ds.field("on", &self.on());
        ds.finish()
    }
}
pub enum GpioGetRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GpioGetRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GpioGetRequest<'a> {
    type Inner = GpioGetRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> GpioGetRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GpioGetRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GpioGetRequestArgs,
    ) -> flatbuffers::WIPOffset<GpioGetRequest<'bldr>> {
        let mut builder = GpioGetRequestBuilder::new(_fbb);
        builder.add_id(args.id);
        builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn id(&self) -> i8 {
        self._tab.get::<i8>(GpioGetRequest::VT_ID, Some(0)).unwrap()
    }
}

impl flatbuffers::Verifiable for GpioGetRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i8>(&"id", Self::VT_ID, false)?
            .finish();
        Ok(())
    }
}
pub struct GpioGetRequestArgs {
    pub id: i8,
}
impl<'a> Default for GpioGetRequestArgs {
    #[inline]
    fn default() -> Self {
        GpioGetRequestArgs { id: 0 }
    }
}
pub struct GpioGetRequestBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GpioGetRequestBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: i8) {
        self.fbb_.push_slot::<i8>(GpioGetRequest::VT_ID, id, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GpioGetRequestBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GpioGetRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GpioGetRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for GpioGetRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("GpioGetRequest");
        ds.field("id", &self.id());
        ds.finish()
    }
}
pub enum GpioButtonStatusOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GpioButtonStatus<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GpioButtonStatus<'a> {
    type Inner = GpioButtonStatus<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> GpioButtonStatus<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GpioButtonStatus { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GpioButtonStatusArgs,
    ) -> flatbuffers::WIPOffset<GpioButtonStatus<'bldr>> {
        let mut builder = GpioButtonStatusBuilder::new(_fbb);
        builder.add_mode(args.mode);
        builder.add_id(args.id);
        builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_MODE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn id(&self) -> u8 {
        self._tab
            .get::<u8>(GpioButtonStatus::VT_ID, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn mode(&self) -> GpioPressedMode {
        self._tab
            .get::<GpioPressedMode>(GpioButtonStatus::VT_MODE, Some(GpioPressedMode::Single))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for GpioButtonStatus<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u8>(&"id", Self::VT_ID, false)?
            .visit_field::<GpioPressedMode>(&"mode", Self::VT_MODE, false)?
            .finish();
        Ok(())
    }
}
pub struct GpioButtonStatusArgs {
    pub id: u8,
    pub mode: GpioPressedMode,
}
impl<'a> Default for GpioButtonStatusArgs {
    #[inline]
    fn default() -> Self {
        GpioButtonStatusArgs {
            id: 0,
            mode: GpioPressedMode::Single,
        }
    }
}
pub struct GpioButtonStatusBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GpioButtonStatusBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: u8) {
        self.fbb_.push_slot::<u8>(GpioButtonStatus::VT_ID, id, 0);
    }
    #[inline]
    pub fn add_mode(&mut self, mode: GpioPressedMode) {
        self.fbb_.push_slot::<GpioPressedMode>(
            GpioButtonStatus::VT_MODE,
            mode,
            GpioPressedMode::Single,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> GpioButtonStatusBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GpioButtonStatusBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GpioButtonStatus<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for GpioButtonStatus<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("GpioButtonStatus");
        ds.field("id", &self.id());
        ds.field("mode", &self.mode());
        ds.finish()
    }
}
pub enum AudioFileOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AudioFile<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AudioFile<'a> {
    type Inner = AudioFile<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> AudioFile<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AudioFile { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AudioFileArgs<'args>,
    ) -> flatbuffers::WIPOffset<AudioFile<'bldr>> {
        let mut builder = AudioFileBuilder::new(_fbb);
        if let Some(x) = args.payload {
            builder.add_payload(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn type_(&self) -> AudioType {
        self._tab
            .get::<AudioType>(AudioFile::VT_TYPE_, Some(AudioType::MP3))
            .unwrap()
    }
    #[inline]
    pub fn payload(&self) -> &'a [i8] {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(
                AudioFile::VT_PAYLOAD,
                None,
            )
            .map(|v| v.safe_slice())
            .unwrap()
    }
}

impl flatbuffers::Verifiable for AudioFile<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<AudioType>(&"type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(
                &"payload",
                Self::VT_PAYLOAD,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct AudioFileArgs<'a> {
    pub type_: AudioType,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for AudioFileArgs<'a> {
    #[inline]
    fn default() -> Self {
        AudioFileArgs {
            type_: AudioType::MP3,
            payload: None, // required field
        }
    }
}
pub struct AudioFileBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AudioFileBuilder<'a, 'b> {
    #[inline]
    pub fn add_type_(&mut self, type_: AudioType) {
        self.fbb_
            .push_slot::<AudioType>(AudioFile::VT_TYPE_, type_, AudioType::MP3);
    }
    #[inline]
    pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AudioFile::VT_PAYLOAD, payload);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AudioFileBuilder<'a, 'b> {
        let start = _fbb.start_table();
        AudioFileBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AudioFile<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, AudioFile::VT_PAYLOAD, "payload");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for AudioFile<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("AudioFile");
        ds.field("type_", &self.type_());
        ds.field("payload", &self.payload());
        ds.finish()
    }
}
pub enum AudioPlaylistOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AudioPlaylist<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AudioPlaylist<'a> {
    type Inner = AudioPlaylist<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> AudioPlaylist<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AudioPlaylist { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AudioPlaylistArgs<'args>,
    ) -> flatbuffers::WIPOffset<AudioPlaylist<'bldr>> {
        let mut builder = AudioPlaylistBuilder::new(_fbb);
        builder.add_delay(args.delay);
        builder.add_loop_(args.loop_);
        if let Some(x) = args.files {
            builder.add_files(x);
        }
        builder.finish()
    }

    pub const VT_FILES: flatbuffers::VOffsetT = 4;
    pub const VT_LOOP_: flatbuffers::VOffsetT = 6;
    pub const VT_DELAY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn files(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AudioFile<'a>>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AudioFile>>,
            >>(AudioPlaylist::VT_FILES, None)
            .unwrap()
    }
    #[inline]
    pub fn loop_(&self) -> u64 {
        self._tab
            .get::<u64>(AudioPlaylist::VT_LOOP_, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn delay(&self) -> u64 {
        self._tab
            .get::<u64>(AudioPlaylist::VT_DELAY, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for AudioPlaylist<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AudioFile>>,
            >>(&"files", Self::VT_FILES, true)?
            .visit_field::<u64>(&"loop_", Self::VT_LOOP_, false)?
            .visit_field::<u64>(&"delay", Self::VT_DELAY, false)?
            .finish();
        Ok(())
    }
}
pub struct AudioPlaylistArgs<'a> {
    pub files: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AudioFile<'a>>>,
        >,
    >,
    pub loop_: u64,
    pub delay: u64,
}
impl<'a> Default for AudioPlaylistArgs<'a> {
    #[inline]
    fn default() -> Self {
        AudioPlaylistArgs {
            files: None, // required field
            loop_: 0,
            delay: 0,
        }
    }
}
pub struct AudioPlaylistBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AudioPlaylistBuilder<'a, 'b> {
    #[inline]
    pub fn add_files(
        &mut self,
        files: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AudioFile<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AudioPlaylist::VT_FILES, files);
    }
    #[inline]
    pub fn add_loop_(&mut self, loop_: u64) {
        self.fbb_
            .push_slot::<u64>(AudioPlaylist::VT_LOOP_, loop_, 0);
    }
    #[inline]
    pub fn add_delay(&mut self, delay: u64) {
        self.fbb_
            .push_slot::<u64>(AudioPlaylist::VT_DELAY, delay, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AudioPlaylistBuilder<'a, 'b> {
        let start = _fbb.start_table();
        AudioPlaylistBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AudioPlaylist<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, AudioPlaylist::VT_FILES, "files");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for AudioPlaylist<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("AudioPlaylist");
        ds.field("files", &self.files());
        ds.field("loop_", &self.loop_());
        ds.field("delay", &self.delay());
        ds.finish()
    }
}
