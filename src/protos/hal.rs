// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum GpioPressedMode {
    Single = 1,
    Double = 2,
    Hold = 3,
}

pub const ENUM_MIN_GPIO_PRESSED_MODE: u8 = 1;
pub const ENUM_MAX_GPIO_PRESSED_MODE: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for GpioPressedMode {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for GpioPressedMode {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = u8::to_le(self as u8);
        let p = &n as *const u8 as *const GpioPressedMode;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = u8::from_le(self as u8);
        let p = &n as *const u8 as *const GpioPressedMode;
        unsafe { *p }
    }
}

impl flatbuffers::Push for GpioPressedMode {
    type Output = GpioPressedMode;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<GpioPressedMode>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GPIO_PRESSED_MODE: [GpioPressedMode; 3] = [
    GpioPressedMode::Single,
    GpioPressedMode::Double,
    GpioPressedMode::Hold,
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_GPIO_PRESSED_MODE: [&'static str; 3] = ["Single", "Double", "Hold"];

pub fn enum_name_gpio_pressed_mode(e: GpioPressedMode) -> &'static str {
    let index = e as u8 - GpioPressedMode::Single as u8;
    ENUM_NAMES_GPIO_PRESSED_MODE[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum AudioType {
    MP3 = 1,
    WAV = 2,
}

pub const ENUM_MIN_AUDIO_TYPE: u8 = 1;
pub const ENUM_MAX_AUDIO_TYPE: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for AudioType {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for AudioType {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = u8::to_le(self as u8);
        let p = &n as *const u8 as *const AudioType;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = u8::from_le(self as u8);
        let p = &n as *const u8 as *const AudioType;
        unsafe { *p }
    }
}

impl flatbuffers::Push for AudioType {
    type Output = AudioType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<AudioType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AUDIO_TYPE: [AudioType; 2] = [AudioType::MP3, AudioType::WAV];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_AUDIO_TYPE: [&'static str; 2] = ["MP3", "WAV"];

pub fn enum_name_audio_type(e: AudioType) -> &'static str {
    let index = e as u8 - AudioType::MP3 as u8;
    ENUM_NAMES_AUDIO_TYPE[index as usize]
}

pub enum TtyRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TtyRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TtyRequest<'a> {
    type Inner = TtyRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TtyRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TtyRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TtyRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<TtyRequest<'bldr>> {
        let mut builder = TtyRequestBuilder::new(_fbb);
        builder.add_delay(args.delay);
        if let Some(x) = args.commands {
            builder.add_commands(x);
        }
        builder.finish()
    }

    pub const VT_COMMANDS: flatbuffers::VOffsetT = 4;
    pub const VT_DELAY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn commands(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(TtyRequest::VT_COMMANDS, None).unwrap()
    }
    #[inline]
    pub fn delay(&self) -> u64 {
        self._tab
            .get::<u64>(TtyRequest::VT_DELAY, Some(300))
            .unwrap()
    }
}

pub struct TtyRequestArgs<'a> {
    pub commands: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub delay: u64,
}
impl<'a> Default for TtyRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        TtyRequestArgs {
            commands: None, // required field
            delay: 300,
        }
    }
}
pub struct TtyRequestBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TtyRequestBuilder<'a, 'b> {
    #[inline]
    pub fn add_commands(
        &mut self,
        commands: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TtyRequest::VT_COMMANDS, commands);
    }
    #[inline]
    pub fn add_delay(&mut self, delay: u64) {
        self.fbb_.push_slot::<u64>(TtyRequest::VT_DELAY, delay, 300);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TtyRequestBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TtyRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TtyRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, TtyRequest::VT_COMMANDS, "commands");
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum TtyResponseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TtyResponse<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TtyResponse<'a> {
    type Inner = TtyResponse<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TtyResponse<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TtyResponse { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TtyResponseArgs<'args>,
    ) -> flatbuffers::WIPOffset<TtyResponse<'bldr>> {
        let mut builder = TtyResponseBuilder::new(_fbb);
        builder.add_delay(args.delay);
        if let Some(x) = args.commands {
            builder.add_commands(x);
        }
        builder.finish()
    }

    pub const VT_COMMANDS: flatbuffers::VOffsetT = 4;
    pub const VT_DELAY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn commands(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(TtyResponse::VT_COMMANDS, None).unwrap()
    }
    #[inline]
    pub fn delay(&self) -> u64 {
        self._tab
            .get::<u64>(TtyResponse::VT_DELAY, Some(300))
            .unwrap()
    }
}

pub struct TtyResponseArgs<'a> {
    pub commands: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub delay: u64,
}
impl<'a> Default for TtyResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        TtyResponseArgs {
            commands: None, // required field
            delay: 300,
        }
    }
}
pub struct TtyResponseBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TtyResponseBuilder<'a, 'b> {
    #[inline]
    pub fn add_commands(
        &mut self,
        commands: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TtyResponse::VT_COMMANDS, commands);
    }
    #[inline]
    pub fn add_delay(&mut self, delay: u64) {
        self.fbb_
            .push_slot::<u64>(TtyResponse::VT_DELAY, delay, 300);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TtyResponseBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TtyResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TtyResponse<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, TtyResponse::VT_COMMANDS, "commands");
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum GpioStatusOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GpioStatus<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GpioStatus<'a> {
    type Inner = GpioStatus<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GpioStatus<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GpioStatus { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GpioStatusArgs,
    ) -> flatbuffers::WIPOffset<GpioStatus<'bldr>> {
        let mut builder = GpioStatusBuilder::new(_fbb);
        builder.add_on(args.on);
        builder.add_id(args.id);
        builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_ON: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn id(&self) -> i8 {
        self._tab.get::<i8>(GpioStatus::VT_ID, Some(0)).unwrap()
    }
    #[inline]
    pub fn on(&self) -> bool {
        self._tab
            .get::<bool>(GpioStatus::VT_ON, Some(false))
            .unwrap()
    }
}

pub struct GpioStatusArgs {
    pub id: i8,
    pub on: bool,
}
impl<'a> Default for GpioStatusArgs {
    #[inline]
    fn default() -> Self {
        GpioStatusArgs { id: 0, on: false }
    }
}
pub struct GpioStatusBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GpioStatusBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: i8) {
        self.fbb_.push_slot::<i8>(GpioStatus::VT_ID, id, 0);
    }
    #[inline]
    pub fn add_on(&mut self, on: bool) {
        self.fbb_.push_slot::<bool>(GpioStatus::VT_ON, on, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GpioStatusBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GpioStatusBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GpioStatus<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum GpioGetRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GpioGetRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GpioGetRequest<'a> {
    type Inner = GpioGetRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GpioGetRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GpioGetRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GpioGetRequestArgs,
    ) -> flatbuffers::WIPOffset<GpioGetRequest<'bldr>> {
        let mut builder = GpioGetRequestBuilder::new(_fbb);
        builder.add_id(args.id);
        builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn id(&self) -> i8 {
        self._tab.get::<i8>(GpioGetRequest::VT_ID, Some(0)).unwrap()
    }
}

pub struct GpioGetRequestArgs {
    pub id: i8,
}
impl<'a> Default for GpioGetRequestArgs {
    #[inline]
    fn default() -> Self {
        GpioGetRequestArgs { id: 0 }
    }
}
pub struct GpioGetRequestBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GpioGetRequestBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: i8) {
        self.fbb_.push_slot::<i8>(GpioGetRequest::VT_ID, id, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GpioGetRequestBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GpioGetRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GpioGetRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum GpioButtonStatusOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GpioButtonStatus<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GpioButtonStatus<'a> {
    type Inner = GpioButtonStatus<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GpioButtonStatus<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GpioButtonStatus { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GpioButtonStatusArgs,
    ) -> flatbuffers::WIPOffset<GpioButtonStatus<'bldr>> {
        let mut builder = GpioButtonStatusBuilder::new(_fbb);
        builder.add_mode(args.mode);
        builder.add_id(args.id);
        builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_MODE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn id(&self) -> u8 {
        self._tab
            .get::<u8>(GpioButtonStatus::VT_ID, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn mode(&self) -> GpioPressedMode {
        self._tab
            .get::<GpioPressedMode>(GpioButtonStatus::VT_MODE, Some(GpioPressedMode::Single))
            .unwrap()
    }
}

pub struct GpioButtonStatusArgs {
    pub id: u8,
    pub mode: GpioPressedMode,
}
impl<'a> Default for GpioButtonStatusArgs {
    #[inline]
    fn default() -> Self {
        GpioButtonStatusArgs {
            id: 0,
            mode: GpioPressedMode::Single,
        }
    }
}
pub struct GpioButtonStatusBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GpioButtonStatusBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: u8) {
        self.fbb_.push_slot::<u8>(GpioButtonStatus::VT_ID, id, 0);
    }
    #[inline]
    pub fn add_mode(&mut self, mode: GpioPressedMode) {
        self.fbb_.push_slot::<GpioPressedMode>(
            GpioButtonStatus::VT_MODE,
            mode,
            GpioPressedMode::Single,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> GpioButtonStatusBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GpioButtonStatusBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GpioButtonStatus<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum AudioFileOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AudioFile<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AudioFile<'a> {
    type Inner = AudioFile<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AudioFile<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AudioFile { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AudioFileArgs<'args>,
    ) -> flatbuffers::WIPOffset<AudioFile<'bldr>> {
        let mut builder = AudioFileBuilder::new(_fbb);
        if let Some(x) = args.payload {
            builder.add_payload(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn type_(&self) -> AudioType {
        self._tab
            .get::<AudioType>(AudioFile::VT_TYPE_, Some(AudioType::MP3))
            .unwrap()
    }
    #[inline]
    pub fn payload(&self) -> &'a [i8] {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(
                AudioFile::VT_PAYLOAD,
                None,
            )
            .map(|v| v.safe_slice())
            .unwrap()
    }
}

pub struct AudioFileArgs<'a> {
    pub type_: AudioType,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for AudioFileArgs<'a> {
    #[inline]
    fn default() -> Self {
        AudioFileArgs {
            type_: AudioType::MP3,
            payload: None, // required field
        }
    }
}
pub struct AudioFileBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AudioFileBuilder<'a, 'b> {
    #[inline]
    pub fn add_type_(&mut self, type_: AudioType) {
        self.fbb_
            .push_slot::<AudioType>(AudioFile::VT_TYPE_, type_, AudioType::MP3);
    }
    #[inline]
    pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AudioFile::VT_PAYLOAD, payload);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AudioFileBuilder<'a, 'b> {
        let start = _fbb.start_table();
        AudioFileBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AudioFile<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, AudioFile::VT_PAYLOAD, "payload");
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum AudioPlayListOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AudioPlayList<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AudioPlayList<'a> {
    type Inner = AudioPlayList<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AudioPlayList<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AudioPlayList { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AudioPlayListArgs<'args>,
    ) -> flatbuffers::WIPOffset<AudioPlayList<'bldr>> {
        let mut builder = AudioPlayListBuilder::new(_fbb);
        builder.add_delay(args.delay);
        builder.add_loop_(args.loop_);
        if let Some(x) = args.files {
            builder.add_files(x);
        }
        builder.finish()
    }

    pub const VT_FILES: flatbuffers::VOffsetT = 4;
    pub const VT_LOOP_: flatbuffers::VOffsetT = 6;
    pub const VT_DELAY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn files(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AudioFile<'a>>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<AudioFile<'a>>>,
            >>(AudioPlayList::VT_FILES, None)
            .unwrap()
    }
    #[inline]
    pub fn loop_(&self) -> u64 {
        self._tab
            .get::<u64>(AudioPlayList::VT_LOOP_, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn delay(&self) -> u64 {
        self._tab
            .get::<u64>(AudioPlayList::VT_DELAY, Some(0))
            .unwrap()
    }
}

pub struct AudioPlayListArgs<'a> {
    pub files: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AudioFile<'a>>>,
        >,
    >,
    pub loop_: u64,
    pub delay: u64,
}
impl<'a> Default for AudioPlayListArgs<'a> {
    #[inline]
    fn default() -> Self {
        AudioPlayListArgs {
            files: None, // required field
            loop_: 0,
            delay: 0,
        }
    }
}
pub struct AudioPlayListBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AudioPlayListBuilder<'a, 'b> {
    #[inline]
    pub fn add_files(
        &mut self,
        files: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AudioFile<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AudioPlayList::VT_FILES, files);
    }
    #[inline]
    pub fn add_loop_(&mut self, loop_: u64) {
        self.fbb_
            .push_slot::<u64>(AudioPlayList::VT_LOOP_, loop_, 0);
    }
    #[inline]
    pub fn add_delay(&mut self, delay: u64) {
        self.fbb_
            .push_slot::<u64>(AudioPlayList::VT_DELAY, delay, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AudioPlayListBuilder<'a, 'b> {
        let start = _fbb.start_table();
        AudioPlayListBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AudioPlayList<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, AudioPlayList::VT_FILES, "files");
        flatbuffers::WIPOffset::new(o.value())
    }
}
