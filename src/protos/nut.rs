// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum MediaType {
    Plain = 1,
    Html = 2,
    Markdown = 3,
}

pub const ENUM_MIN_MEDIA_TYPE: u8 = 1;
pub const ENUM_MAX_MEDIA_TYPE: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for MediaType {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::read_scalar_at::<Self>(buf, loc)
    }
}

impl flatbuffers::EndianScalar for MediaType {
    #[inline]
    fn to_little_endian(self) -> Self {
        let n = u8::to_le(self as u8);
        let p = &n as *const u8 as *const MediaType;
        unsafe { *p }
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let n = u8::from_le(self as u8);
        let p = &n as *const u8 as *const MediaType;
        unsafe { *p }
    }
}

impl flatbuffers::Push for MediaType {
    type Output = MediaType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<MediaType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MEDIA_TYPE: [MediaType; 3] =
    [MediaType::Plain, MediaType::Html, MediaType::Markdown];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_MEDIA_TYPE: [&'static str; 3] = ["Plain", "Html", "Markdown"];

pub fn enum_name_media_type(e: MediaType) -> &'static str {
    let index = e as u8 - MediaType::Plain as u8;
    ENUM_NAMES_MEDIA_TYPE[index as usize]
}

pub enum EmailTaskOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EmailTask<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EmailTask<'a> {
    type Inner = EmailTask<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EmailTask<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EmailTask { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EmailTaskArgs<'args>,
    ) -> flatbuffers::WIPOffset<EmailTask<'bldr>> {
        let mut builder = EmailTaskBuilder::new(_fbb);
        if let Some(x) = args.body {
            builder.add_body(x);
        }
        if let Some(x) = args.subject {
            builder.add_subject(x);
        }
        if let Some(x) = args.bcc {
            builder.add_bcc(x);
        }
        if let Some(x) = args.cc {
            builder.add_cc(x);
        }
        if let Some(x) = args.to {
            builder.add_to(x);
        }
        builder.add_media_type(args.media_type);
        builder.finish()
    }

    pub const VT_TO: flatbuffers::VOffsetT = 4;
    pub const VT_CC: flatbuffers::VOffsetT = 6;
    pub const VT_BCC: flatbuffers::VOffsetT = 8;
    pub const VT_SUBJECT: flatbuffers::VOffsetT = 10;
    pub const VT_BODY: flatbuffers::VOffsetT = 12;
    pub const VT_MEDIA_TYPE: flatbuffers::VOffsetT = 14;

    #[inline]
    pub fn to(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EmailTask::VT_TO, None)
            .unwrap()
    }
    #[inline]
    pub fn cc(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(EmailTask::VT_CC, None).unwrap()
    }
    #[inline]
    pub fn bcc(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(EmailTask::VT_BCC, None).unwrap()
    }
    #[inline]
    pub fn subject(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EmailTask::VT_SUBJECT, None)
            .unwrap()
    }
    #[inline]
    pub fn body(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EmailTask::VT_BODY, None)
            .unwrap()
    }
    #[inline]
    pub fn media_type(&self) -> MediaType {
        self._tab
            .get::<MediaType>(EmailTask::VT_MEDIA_TYPE, Some(MediaType::Plain))
            .unwrap()
    }
}

pub struct EmailTaskArgs<'a> {
    pub to: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cc: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub bcc: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub subject: Option<flatbuffers::WIPOffset<&'a str>>,
    pub body: Option<flatbuffers::WIPOffset<&'a str>>,
    pub media_type: MediaType,
}
impl<'a> Default for EmailTaskArgs<'a> {
    #[inline]
    fn default() -> Self {
        EmailTaskArgs {
            to: None,      // required field
            cc: None,      // required field
            bcc: None,     // required field
            subject: None, // required field
            body: None,    // required field
            media_type: MediaType::Plain,
        }
    }
}
pub struct EmailTaskBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EmailTaskBuilder<'a, 'b> {
    #[inline]
    pub fn add_to(&mut self, to: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EmailTask::VT_TO, to);
    }
    #[inline]
    pub fn add_cc(
        &mut self,
        cc: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EmailTask::VT_CC, cc);
    }
    #[inline]
    pub fn add_bcc(
        &mut self,
        bcc: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EmailTask::VT_BCC, bcc);
    }
    #[inline]
    pub fn add_subject(&mut self, subject: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EmailTask::VT_SUBJECT, subject);
    }
    #[inline]
    pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EmailTask::VT_BODY, body);
    }
    #[inline]
    pub fn add_media_type(&mut self, media_type: MediaType) {
        self.fbb_
            .push_slot::<MediaType>(EmailTask::VT_MEDIA_TYPE, media_type, MediaType::Plain);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EmailTaskBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EmailTaskBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EmailTask<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, EmailTask::VT_TO, "to");
        self.fbb_.required(o, EmailTask::VT_CC, "cc");
        self.fbb_.required(o, EmailTask::VT_BCC, "bcc");
        self.fbb_.required(o, EmailTask::VT_SUBJECT, "subject");
        self.fbb_.required(o, EmailTask::VT_BODY, "body");
        flatbuffers::WIPOffset::new(o.value())
    }
}
