// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_MEDIA_TYPE: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_MEDIA_TYPE: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MEDIA_TYPE: [MediaType; 3] =
    [MediaType::Plain, MediaType::Html, MediaType::Markdown];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MediaType(pub u8);
#[allow(non_upper_case_globals)]
impl MediaType {
    pub const Plain: Self = Self(1);
    pub const Html: Self = Self(2);
    pub const Markdown: Self = Self(3);

    pub const ENUM_MIN: u8 = 1;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Plain, Self::Html, Self::Markdown];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Plain => Some("Plain"),
            Self::Html => Some("Html"),
            Self::Markdown => Some("Markdown"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for MediaType {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for MediaType {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for MediaType {
    type Output = MediaType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MediaType {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for MediaType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for MediaType {}
pub enum EmailTaskOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EmailTask<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EmailTask<'a> {
    type Inner = EmailTask<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> EmailTask<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EmailTask { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EmailTaskArgs<'args>,
    ) -> flatbuffers::WIPOffset<EmailTask<'bldr>> {
        let mut builder = EmailTaskBuilder::new(_fbb);
        if let Some(x) = args.body {
            builder.add_body(x);
        }
        if let Some(x) = args.subject {
            builder.add_subject(x);
        }
        if let Some(x) = args.bcc {
            builder.add_bcc(x);
        }
        if let Some(x) = args.cc {
            builder.add_cc(x);
        }
        if let Some(x) = args.to {
            builder.add_to(x);
        }
        builder.add_media_type(args.media_type);
        builder.finish()
    }

    pub const VT_TO: flatbuffers::VOffsetT = 4;
    pub const VT_CC: flatbuffers::VOffsetT = 6;
    pub const VT_BCC: flatbuffers::VOffsetT = 8;
    pub const VT_SUBJECT: flatbuffers::VOffsetT = 10;
    pub const VT_BODY: flatbuffers::VOffsetT = 12;
    pub const VT_MEDIA_TYPE: flatbuffers::VOffsetT = 14;

    #[inline]
    pub fn to(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EmailTask::VT_TO, None)
            .unwrap()
    }
    #[inline]
    pub fn cc(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(EmailTask::VT_CC, None)
            .unwrap()
    }
    #[inline]
    pub fn bcc(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(EmailTask::VT_BCC, None)
            .unwrap()
    }
    #[inline]
    pub fn subject(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EmailTask::VT_SUBJECT, None)
            .unwrap()
    }
    #[inline]
    pub fn body(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EmailTask::VT_BODY, None)
            .unwrap()
    }
    #[inline]
    pub fn media_type(&self) -> MediaType {
        self._tab
            .get::<MediaType>(EmailTask::VT_MEDIA_TYPE, Some(MediaType::Plain))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for EmailTask<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"to", Self::VT_TO, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(&"cc", Self::VT_CC, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(&"bcc", Self::VT_BCC, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"subject", Self::VT_SUBJECT, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"body", Self::VT_BODY, true)?
            .visit_field::<MediaType>(&"media_type", Self::VT_MEDIA_TYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct EmailTaskArgs<'a> {
    pub to: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cc: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub bcc: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub subject: Option<flatbuffers::WIPOffset<&'a str>>,
    pub body: Option<flatbuffers::WIPOffset<&'a str>>,
    pub media_type: MediaType,
}
impl<'a> Default for EmailTaskArgs<'a> {
    #[inline]
    fn default() -> Self {
        EmailTaskArgs {
            to: None,      // required field
            cc: None,      // required field
            bcc: None,     // required field
            subject: None, // required field
            body: None,    // required field
            media_type: MediaType::Plain,
        }
    }
}
pub struct EmailTaskBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EmailTaskBuilder<'a, 'b> {
    #[inline]
    pub fn add_to(&mut self, to: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EmailTask::VT_TO, to);
    }
    #[inline]
    pub fn add_cc(
        &mut self,
        cc: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EmailTask::VT_CC, cc);
    }
    #[inline]
    pub fn add_bcc(
        &mut self,
        bcc: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EmailTask::VT_BCC, bcc);
    }
    #[inline]
    pub fn add_subject(&mut self, subject: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EmailTask::VT_SUBJECT, subject);
    }
    #[inline]
    pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EmailTask::VT_BODY, body);
    }
    #[inline]
    pub fn add_media_type(&mut self, media_type: MediaType) {
        self.fbb_
            .push_slot::<MediaType>(EmailTask::VT_MEDIA_TYPE, media_type, MediaType::Plain);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EmailTaskBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EmailTaskBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EmailTask<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, EmailTask::VT_TO, "to");
        self.fbb_.required(o, EmailTask::VT_CC, "cc");
        self.fbb_.required(o, EmailTask::VT_BCC, "bcc");
        self.fbb_.required(o, EmailTask::VT_SUBJECT, "subject");
        self.fbb_.required(o, EmailTask::VT_BODY, "body");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for EmailTask<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("EmailTask");
        ds.field("to", &self.to());
        ds.field("cc", &self.cc());
        ds.field("bcc", &self.bcc());
        ds.field("subject", &self.subject());
        ds.field("body", &self.body());
        ds.field("media_type", &self.media_type());
        ds.finish()
    }
}
